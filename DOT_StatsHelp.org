#+TITLE:  Julia Package That Helps With Statistics For Random Processes
#+AUTHOR: Dirk Oliver Theis, University of Tartu, Estonia
#+EMAIL:  dotheis@ut.ee
#+DATE:   Fri Aug 11 11:19:58 CEST 2023

#+STARTUP: latexpreview
#+STARTUP: show3levels
#+BIBLIOGRAPHY: ../../DOT_LaTeX/dirks.bib
#+PROPERTY: header-args :eval never :comments link :exports code
#+SEQ_TODO: TODO IN-PRGR TSTNG BROKEN | DONE

* Copyright Notice

   The following copyright notice applies to this Org-file, as well as the Julia source file generated from it.

   #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
     #########################################################################
     #                                                                       #
     # Copyright and Licensing Information                                   #
     # -----------------------------------                                   #
     #                                                                       #
     # Copyright lies with the University of Tartu, Estonia, and with the    #
     # author.                                                               #
     #                                                                       #
     # Permission is hereby granted to use and modify the source code under  #
     # the terms of the Apache v2.0 license.                                 #
     #                                                                       #
     #                                                                       #
     # Author:                                                               #
     #                                                                       #
     #        Dirk Oliver Theis                                              #
     #        Assoc. Prof. Theoretical Computer Science                      #
     #        University of Tartu                                            #
     #        Estonia                                                        #
     #                                                                       #
     #########################################################################
   #+END_SRC


* What's This Module/Project/File About?
** TODO Summary of what this software does [0/1] <<summary>>
** TODO High-level usage instructions <<hl-usage>> [0/0]
*** TODO Steps and runs [0/1]
     The fundamental idea is to run a random process for so-and-so many /steps/, collecting information about its
     convergence.  This is repeated for so-and-so-many /runs/, and statistics about the convergence are created.

     The user must stick to the following order of instructions for using the types defined in the module:

       1. create an object of the type using the [[mp-constructor][constructor]];
       2. For each run:
          1. Start a new run using the [[start][~start_run!()~ function]]
          2. Fill run with data using the [[record][~record_step!()~ function]] repeatedly, once for every step
          3. Call the [[finalize][~finalize_run!()~ function]] to for tidying up the run
          4. Retrieve the stats that are overwritten in each run \\
             (e.g., the empirical mean in for mean-estimating processes is kept only for the current run)
       3. Repeat -- i.e., Goto (2) --  for all runs
       4. Retrieve the stored stats over all runs.

     The links above are to the functions for mean-estimating processes, but the user interface is identical for
     the max-approximating processes.

     + [ ] *Are they?!?*

** Literate programming

   This document is a "literate program", i.e., plain text interspersed with actual Julia programming language
   source code.  The source code is extracted ("tangled") into the files [fn:: ~src/DOT_StatsHelp.jl~] and [fn::
   ~tmp/runtests.jl~], from where it can be run etc.

   Literate programming allows me to organize source code, documentation, and tests in a hierarchical, text
   document structure.  This makes orientation in the source code so much easier üòä than in a linear source stream.


* Task Lists and Progress Reports [2/4]
** DONE Basics [1/1]

     + [X] Set up repository [6/6]

       - [X] Create repository
       - [X] Make it Org
       - [X] Set up TOML files
       - [X] Copy content from ShiftRules/SPSA ~Stats~
       - [X] Make version v0.1
       - [X] Register on ~DOT_JuliaPackages~

** DONE Mean-estimating process [8/8]

     + [X] Make it work, basically [1/1]

       - [X] Work source code

     + [X] Work the many-runs

     + [X] Make it type independent \\
           Solved by using valency-0 tensors.

     + [X] ~export~

     + [X] Describe the functions

     + [X] *Fix mistake in emp var calculation !!*

     + [X] Add unit tests

     + [X] Add more unit tests

** TODO Max-approximating process [0/0]
** TODO Finally, ... [0/2]

     + [ ] Write the [[summary][Summary]]

     + [ ] Acknowledge funding: NeQst WP4


* TODO Literate Source Code for the Package [4/6]

** DONE File headers

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

    #+BEGIN_SRC julia :tangle test/runtests.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################

      using Test
      using DOT_StatsHelp
    #+END_SRC


** DONE Set up testing
**** Importing things
      #+BEGIN_SRC julia :tangle test/runtests.jl
        using DoubleFloats: Double64

        using LinearAlgebra: norm_sqr as norm2¬≤, norm2, norm1, normInf as norm‚àû

        using Statistics: mean, var

        using DOT_NiceMath
      #+END_SRC

**** Generic test based on ~JET.jl~
    #+BEGIN_SRC julia :tangle test/runtests.jl
      using JET
      using JSON        # Only for ignoring by JET
      using Polynomials # Only for ignoring by JET

      @testset verbose=true "DOT_StatsHelp.jl testing:  via JET.jl" begin
          test_package(DOT_StatsHelp, ignored_modules=(AnyFrameModule(JSON.Parser),AnyFrameModule(Polynomials),) )
      end
    #+END_SRC


** DONE Module definition & imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      module DOT_StatsHelp
    #+END_SRC

    Imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      using DOT_NiceMath            # `‚ãÖ` = `*`  etc
      using DOT_NiceMath.Numbers64  # ‚Ñù, ‚Ñ§, ‚Ñö

      using LinearAlgebra: norm2, norm1, normInf as norm‚àû, norm_sqr as norm2¬≤,
                           axpy!, axpby!
    #+END_SRC


** TSTNG Statistics of mean-estimating processes
*** The mean process type: ~MeanProc{ùêë,V}~

     The following basic type is made available to the user:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export MeanProc
     #+END_SRC

     An object of this type collects information about the stochastic convergence of the empirical mean of random
     ~Array~ objects to a known(!) limit.

    Let's define it.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       struct MeanProc{ùêë <: Real, V}              # `V` is an integer: the valency of the tensor
     #+END_SRC

     _Parameters:_

     + ~ùêë~ is the real-number type used for computations.  The user-facing [[mp-constructor][constructor]] defaults this to
       ~NiceMath~'s ~‚Ñù~, which, here is ~Float64~.  If you are worried that cancellations affect the accuracy of
       the overall outcome, use something the package ~DoubleFloats~, or even, if you're patient, ~BigFloats~.

     + ~V~ is a non-negative integer that gives the valency of the tensors that are being averaged, i.e., ~V~ $=1$
       for a vectors, ~V~ $=2$ for matrices, etc.  With ~V~ $=0$ you get scalars.[fn:: Almost -- it's not the same
       type in Julia.]

**** Fields and inner constructor

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            #            Input for run
            curr_true_Œº  ::Array{‚Ñù, V} #                      size: dimension

            #            Output of run
            curr_emp_Œº   ::Array{ùêë, V} #                      size: dimension

            #            Overall output
            err2¬≤        ::Array{‚Ñù,2}  # 2-norm of tensor; \
            err1         ::Array{‚Ñù,2}  # 1-norm  ~          | size: `steps` ‚úï `runs`
            err‚àû         ::Array{‚Ñù,2}  # ‚àû-norm  ~         /
            emp_var      ::Vector{ùêë}   #                      size: `runs`

            #             Work space
            _ws          ::Array{ùêë,V}  #                      size: dimension

            #             Counters
            ùê´            ::Ref{Int}    # index of upcoming run (i.e., 0 ‚™Æ before first run)
            ùê¨            ::Ref{Int}    # index of upcoming step (i.e., 0 ‚™Æ before first step)

            #
            # Convenience constructor -- not for the user
            #
            function
            MeanProc{ùêë,V}(;
                       curr_true_Œº ::Array{‚Ñù,V}, curr_emp_Œº ::Array{ùêë,V}, emp_var ::Vector{ùêë},
                       err2¬≤ ::Array{‚Ñù,2}, err1 ::Array{‚Ñù,2}, err‚àû ::Array{‚Ñù,2}, _ws ::Array{ùêë,V}) where{ùêë,V}
                new(curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, _ws,
                    0,0)
            end
        end
      #+END_SRC

*** Usage

     The [[hl-usage][high-level usage instructios]] are above.  Note that the empirical mean of a run is not stored, it's
     overwritten by the next run.

     There are inquiry functions for retrieving the stats: In #4, user can retrieve:

       + The square error over the steps of the run, e.g.,           ~err2¬≤(  mp ; run=9, step=27)~
       + The 1-norm of the error over the steps, e.g.,               ~err1(   mp ; run=9, step=27)~
       + The infty-norm of the error over the steps, e.g.,           ~err‚àû(   mp ; run=9, step=27)~
       + The empirical variance of the estimator for the run,, e.g., ~emp_var(mp ; run=9, step=27)~

       + For step 2.4, there's also the function:                    ~curr_emp_Œº(mp)~

     The inquiry functions
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl

       export err2¬≤, err1, err‚àû, emp_var, curr_emp_Œº

     #+END_SRC
     are inconvenient for plotting and whatnot, where direct access to the matrices is better.  The implementations
     of the inquiry functions make clear how that works:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       err2¬≤(  s ::MeanProc{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err2¬≤[step,run] )
       err1(   s ::MeanProc{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err1[ step,run] )
       err‚àû(   s ::MeanProc{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err‚àû[ step,run] )
       emp_var(s ::MeanProc{ùêë,V}; run ::Int)             where{ùêë,V} = ( @assert 1    ‚â§run ‚â§ s.ùê´[]             ; s.emp_var[run]    )

       curr_emp_Œº(s ::MeanProc{ùêë,V})                     where{ùêë,V} = ( @assert 1 ‚â§ s.ùê´[]                     ; s.curr_emp_Œº      )
     #+END_SRC

     #+BEGIN_CENTER
     *Warning!*

     Don't forget that the empirical variance is only available after calling [[finalize][~finalize_run!()~]]
     #+END_CENTER

*** User-facing constructor for ~MeanProc~  <<mp-constructor>>

     The constructor takes the following arguments.

       + The dimension of the underlying tensors, e.g., ~()~ for valency-0 tensors;
       + The number of steps in each run;
       + The number of runs.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function MeanProc(dimension ::NTuple{V,Int}
                         ;
                         steps :: Int,
                         runs  :: Int,
                         ùêë     :: Type{<:Real} = ‚Ñù)  ::MeanProc     where{V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           curr_true_Œº   = Array{‚Ñù,V}(undef, dimension )
           curr_emp_Œº    = Array{ùêë,V}(undef, dimension )   ; curr_emp_Œº   .= ùêë(0)
           _ws           = Array{ùêë,V}(undef, dimension )

           err2¬≤         = Array{‚Ñù,2}(undef, steps,runs)
           err1          = Array{‚Ñù,2}(undef, steps,runs)
           err‚àû          = Array{‚Ñù,2}(undef, steps,runs)
           emp_var       = Array{ùêë,1}(undef, runs)         ; emp_var .= ùêë(0)

           return MeanProc{ùêë,V}( ; curr_true_Œº, curr_emp_Œº,
                                err2¬≤, err1, err‚àû, emp_var,  _ws)
       end
     #+END_SRC

*** Helper functions and integrity check

     The following helper functions are not exported, but can be used by the desperate user.

     _Info about sizes of arrays._

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       valency(        s ::MeanProc{ùêë,V} ) where{ùêë,V}    = V
       dimension(      s ::MeanProc{ùêë,V} ) where{ùêë,V}    = size( s.curr_true_Œº )
       numo_stepsruns( s ::MeanProc{ùêë,V} ) where{ùêë,V}    = size( s.err2¬≤       )
       numo_steps(     s ::MeanProc{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> first
       numo_runs(      s ::MeanProc{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> last
     #+END_SRC

     _Data integrity check_ that throws an exception if there's a problem (otherwise returns nothing).

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function _integrity_check(s ::MeanProc{ùêë,V}) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            @assert size( s.curr_true_Œº ) == dimension(s) == size( s.curr_emp_Œº  )

            let steps  = numo_steps(s),
                runs   = numo_runs(s),
                dim    = dimension(s)

                @assert steps > 1
                @assert runs  ‚â• 1

                @assert 0 ‚â§ s.ùê´[] ‚â§ runs
                @assert 0 ‚â§ s.ùê¨[] ‚â§ steps

                @assert size(     s.err2¬≤       ) == (steps,runs)
                @assert size(     s.err1        ) == (steps,runs)
                @assert size(     s.err‚àû        ) == (steps,runs)
                @assert size(     s.emp_var     ) == (runs,)

                @assert size(     s._ws         ) == dim
            end #^ let
            return nothing
        end
      #+END_SRC

*** Starting a new run: ~start_run!()~ <<start>>

     When a new run starts, the true mean has to be recorded, the indices ùê´ and ùê¨ for run and step, resp., have to
     be set up, and the empirical data has to be initialized.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export start_run!

       function start_run!(s      :: MeanProc{ùêë,V}
                           ;
                           true_Œº :: Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Working with valency-0 tensors -- aka 0-dimensional arrays
     :PROPERTIES:
     :header-args: :tangle no :session JULIA-1 :eval yes :results output :exports both
     :END:

     The Julia function ~fill()~ can create a valency-0 tensor (0-dimensional array) from a scalar:

     #+BEGIN_SRC julia :tangle no
       a = fill( 3.141 )
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : 3.141

     #+BEGIN_SRC julia :tangle no
       typeof( a )
     #+END_SRC

     #+RESULTS:
     : Array{Float64, 0}

     #+BEGIN_SRC julia :tangle no
       a .- œÄ
     #+END_SRC

     #+RESULTS:
     : -0.0005926535897931018

     #+BEGIN_SRC julia :tangle no
       a .-= œÄ
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : -0.0005926535897931018

**** Implementation of ~start_run!()~
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            _integrity_check(s)


            if    s.ùê´[] > 0         @assert s.ùê¨[] == numo_steps(s)
            else                    @assert s.ùê¨[] == 0               end

            s.ùê´[] += 1            ; @assert s.ùê´[] ‚â§ numo_runs(s)
            s.ùê¨[]  = 0

            @assert size(true_Œº) == dimension(s)

            let ùê´ = s.ùê´[],
                ùê¨ = s.ùê¨[]

                s.curr_true_Œº .= true_Œº
                s.curr_emp_Œº  .= ùêë(0)
                s.emp_var[ùê´]   = ùêë(0)

            end
            nothing;
        end #^ start_run!()
      #+END_SRC

*** Adding data of a step: ~record_step!()~ <<record>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export record_step!

       function record_step!(s ::MeanProc{ùêë,V}
                             ;
                             ùê∏ ::Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
                _integrity_check(s)

                (;curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, _ws) = s


                s.ùê¨[] += 1            ; @assert s.ùê¨[] ‚â§ numo_steps(s)

                let ùê´     = s.ùê´[],
                    ùê¨     = s.ùê¨[],
                    steps = numo_steps(s)

                    #
                    # Note order between emp var and emp Œº
                    #
                    # emp_var[ùê´]   = (ùê¨-1) ‚ãÖ emp_var[ùê´]  / ùê¨    +   (ùê¨-1) ‚ãÖ norm2¬≤( curr_emp_Œº - ùê∏ ) / ùê¨¬≤
                    # curr_emp_Œº  .= (ùê¨-1) ‚ãÖ curr_emp_Œº / ùê¨   +   ùê∏ / ùê¨

                    _ws         .= curr_emp_Œº
                    axpby!(-1/ùê¨, ùê∏,  1/ùê¨, _ws)
                    emp_var[ùê´]   = (ùê¨-1) ‚ãÖ (   emp_var[ùê´]  / ùê¨    +   norm2¬≤( _ws )   )
                                  # will be corrected for bias in finalize_run!()

                    axpby!( 1/ùê¨, ùê∏, (ùê¨-1)/ùê¨, curr_emp_Œº)

                    #
                    # Errors
                    #
                    _ws         .= curr_emp_Œº - curr_true_Œº

                    err2¬≤[ùê¨,ùê´]   = norm2¬≤(_ws)
                    err1[ ùê¨,ùê´]   = norm1(_ws)
                    err‚àû[ ùê¨,ùê´]   = norm‚àû(_ws)
                end #^ let
                nothing;
                end #^ record_step!()
      #+END_SRC

*** Finalizing a run: ~finalize_run!()~ <<finalize>>

     The ~finalize_run!()~ function must be called after all data points have been added.  It removes the bias
     from the empirical variance.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export finalize_run!

       function finalize_run!(s ::MeanProc{ùêë,V}) ::Nothing                  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
          _integrity_check(s)

          @assert s.ùê¨[] == numo_steps(s)

          #
          # Un-bias empirical variance:
          #
            let ùê´     = s.ùê´[],
                ùê¨     = s.ùê¨[]

                s.emp_var[ ùê´ ] *= ùê¨ / ùêë(ùê¨-1)
            end
          nothing;
        end #^ finalize_run!()
      #+END_SRC

*** Tests for the mean process
**** Set up testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset verbose=true "DOT_StatsHelp.jl testing: Test MeanProc{}" begin
      #+END_SRC

**** Test with valency 0

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_0(;runs=1:10,steps=2:4:20)
            for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                data = 100*randn(curr_steps,curr_runs)

                mp = MeanProc( () ; steps=curr_steps, runs=curr_runs, ùêë=Double64)

                for run = 1:curr_runs

                    start_run!(mp ; true_Œº = fill(0.0) )

                    for step = 1:curr_steps
                        record_step!(mp ; ùê∏ = fill(data[step,run]) )
                        @test curr_emp_Œº(mp)[]  ‚âà mean( @view data[1:step,run] )
                    end
                    finalize_run!(mp)

                    @test emp_var(mp;run)         ‚âà var(  @view data[:,run] )

                    for step=1:curr_steps
                        @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> abs¬≤
                    end
                    @test all(
                        err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> abs
                        for step=1:curr_steps
                    )
                    @test all(
                        err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> abs
                        for step=1:curr_steps
                    )

                end #^ for run

            end #^ for curr_...
        end #^ test__meanestim_0()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-0 tests" begin
            test__meanestim_0()
        end
      #+END_SRC

**** Test with valency 1

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_1(;runs=1:3:9,steps=2:5:12)
            for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                dim  = 31

                data = [ randn(dim) for s=1:curr_steps, r=1:curr_runs ]

                mp = MeanProc( (dim,) ; steps=curr_steps, runs=curr_runs, ùêë=Double64)

                for run = 1:curr_runs

                    start_run!(mp ; true_Œº = zeros(31) )

                    for step = 1:curr_steps
                        record_step!(mp ; ùê∏ = data[step,run] )
                        @test curr_emp_Œº(mp)  ‚âà mean( @view data[1:step,run] )
                    end
                    finalize_run!(mp)

                    @test emp_var(mp;run)         ‚âà var( @view data[:,run] ) |> norm1 # Julia `var` returns array

                    for step=1:curr_steps
                        @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> norm2¬≤
                    end
                    @test all(
                        err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm1
                        for step=1:curr_steps
                    )
                    @test all(
                        err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm‚àû
                        for step=1:curr_steps
                    )

                end #^ for run

            end #^ for curr_...
        end #^ test__meanestim_1()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-1 tests" begin
            test__meanestim_1()
        end
      #+END_SRC

**** Test with valency 2

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_2(;runs=1:3:9,steps=2:5:12)
            for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                sz  = (7,13)

                data = [ randn(sz) for s=1:curr_steps, r=1:curr_runs ]

                mp = MeanProc( (sz) ; steps=curr_steps, runs=curr_runs, ùêë=Double64)

                for run = 1:curr_runs

                    start_run!(mp ; true_Œº = zeros(sz) )

                    for step = 1:curr_steps
                        record_step!(mp ; ùê∏ = data[step,run] )
                        @test curr_emp_Œº(mp)  ‚âà mean( @view data[1:step,run] )
                    end
                    finalize_run!(mp)

                    @test emp_var(mp;run)         ‚âà var( @view data[:,run] ) |> norm1 # Julia `var` returns array

                    for step=1:curr_steps
                        @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> norm2¬≤
                    end
                    @test all(
                        err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm1
                        for step=1:curr_steps
                    )
                    @test all(
                        err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm‚àû
                        for step=1:curr_steps
                    )

                end #^ for run

            end #^ for curr_...
        end #^ test__meanestim_1()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-2 tests" begin
            test__meanestim_2()
        end
      #+END_SRC

**** End of testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        end #^ testset
      #+END_SRC


** TODO Statistics of max-approximating processes [0/1]
*** TSTNG Helper: ~Xtiles~ type for percentiles
**** Description

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        export Xtiles
      #+END_SRC

      The [[Type--Xtiles][helper-type ~Xtiles~]] counts percentiles.  An object of the type is [[Xtiles-constructor][constructed]] by giving a set of numbers
      in $\left]0,1\right]$, and the total number or data points that will be added over its lifetime.  A call to
      the function [[Xtiles-count_it!][~count_it!()~]] then registers a data point by increasing the frequency for the interval
      $\left]\pi_{\ell-1},\pi_\ell\right]$ out of $\ell=1,\dots,L$ to which it belongs (where $\pi_0 := 0$).

      We require that 1 is in the set of percentiles (but 0 isn't).

**** Definition of the type

      #+NAME: Type--Xtiles
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        struct Xtiles{L}
            ùùÖ     ::NTuple{L,‚Ñù}   # sorted increasingly
            freqs ::Vector{‚Ñù}
            runs  ::Int
        end
      #+END_SRC

      ~freq[‚Ñì]~ is the frequency of the data points in the interval
      #+BEGIN_CENTER
                        \[
                        \left] \pi_{\ell-1} , \pi_{\ell} \right]
                        \]
      #+END_CENTER
      but with $\pi_{0} := 0$.

      We require that 1 is in the set of percentiles (but 0 isn't).

**** User-facing constructor

      /We require that 1 is in the set of percentiles!/

      #+NAME: Xtiles-constructor
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        function Xtiles(_ùùÖ, runs::Int) ::Xtiles
            ùùÖ = collect(_ùùÖ)
            sort!(ùùÖ)

            @assert runs ‚â• 1
            @assert allunique( ùùÖ )
            @assert 0.0 < ùùÖ[1] ‚â§ ùùÖ[end] == 1.0

            L     = length(ùùÖ)
            freqs = zeros(‚Ñù,L)
            return Xtiles{L}((ùùÖ...,),freqs,runs)
        end
      #+END_SRC

**** Store a percentage (not exported!)

      #+NAME: Xtiles-count_it!
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        function count_it!(xt ::Xtiles{L}, p ::‚Ñù)    where{L}
            @assert 0-1e-50 ‚â§ p
            @assert           p ‚â§ 1+1e-30
            @assert L == length(xt.freqs)

            (;ùùÖ,freqs,runs) = xt

            ‚Ñì = 1
            while ‚Ñì ‚â§ L   &&   ùùÖ[‚Ñì] < p
                ‚Ñì += 1
            end
            ‚Ñì = min(‚Ñì,L)                  # in case of rounding errors near 1.0

            freqs[ ‚Ñì ] += 1/runs

            ( ‚Ñì=‚Ñì,  lo=get(ùùÖ,‚Ñì-1,0.0), hi=ùùÖ[‚Ñì] )
        end
      #+END_SRC

**** Let's test it!
***** Main testing function

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__Xtiles()

            function some_tests__interior(L,ùùÖ)
                m = 16
                N = m‚ãÖL
                xt = Xtiles(ùùÖ,N)
                for ‚Ñì = 1 : L
                    lo = get(xt.ùùÖ,‚Ñì-1,   0.0)
                    hi =     xt.ùùÖ[‚Ñì  ]
                    @test lo < hi || (lo==hi && ‚Ñì==L)
                    for j = 1:m
                        p =  lo + (hi-lo)‚ãÖrand()
                        iv = DOT_StatsHelp.count_it!(xt,p)
                        @test iv.lo < p ‚â§ iv.hi
                    end
                end

                @test sum(xt.freqs) ‚âà 1
                for ‚Ñì = 1:L
                    @test xt.freqs[‚Ñì] ‚âà m/N
                end
            end

            function some_tests__boundary(L,ùùÖ)
                m = 16
                N = m‚ãÖL
                xt = Xtiles(ùùÖ,N)
                for j = 1:m
                    for ‚Ñì = 1:L
                        lo = get(xt.ùùÖ,‚Ñì-1,   0.0)
                        hi =     xt.ùùÖ[‚Ñì  ]
                        @test lo < hi || (lo==hi && ‚Ñì==L)
                        DOT_StatsHelp.count_it!(xt,hi)
                    end
                end

                @test sum(xt.freqs) ‚âà 1
                for ‚Ñì = 1:L
                    @test xt.freqs[‚Ñì] ‚âà m/N
                end
            end

            for L = 1:10
                ùùÖ = [ rand(L-1)
                      1.0       ]
                some_tests__interior(L,ùùÖ)
                some_tests__boundary(L,ùùÖ)
            end
        end #^ test__Xtiles()
      #+END_SRC

***** Call the testing function
      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset verbose=true "DOT_StatsHelp.jl testing: Test Xtiles helper" begin
            test__Xtiles()
        end
      #+END_SRC

*** TODO Blah


** DONE End of module

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      end #^ module SPSA_Shift
    #+END_SRC

    That's it!



* End of the Org File

I'm saying good-bye with some well-meant file-local Emacs variables!

# Local Variables:
# fill-column: 115
# End:
