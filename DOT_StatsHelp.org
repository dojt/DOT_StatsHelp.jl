#+TITLE:  Julia Package That Helps With Statistics For Random Processes
#+AUTHOR: Dirk Oliver Theis, University of Tartu, Estonia
#+EMAIL:  dotheis@ut.ee
#+DATE:   Fri Aug 11 11:19:58 CEST 2023

#+STARTUP: latexpreview
#+BIBLIOGRAPHY: ../../DOT_LaTeX/dirks.bib
#+PROPERTY: header-args :eval never :comments link :exports code

* Copyright Notice

   The following copyright notice applies to this Org-file, as well as the Julia source file generated from it.

   #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
     #########################################################################
     #                                                                       #
     # Copyright and Licensing Information                                   #
     # -----------------------------------                                   #
     #                                                                       #
     # Copyright lies with the University of Tartu, Estonia, and with the    #
     # author.                                                               #
     #                                                                       #
     # Permission is hereby granted to use and modify the source code under  #
     # the terms of the Apache v2.0 license.                                 #
     #                                                                       #
     #                                                                       #
     # Author:                                                               #
     #                                                                       #
     #        Dirk Oliver Theis                                              #
     #        Assoc. Prof. Theoretical Computer Science                      #
     #        University of Tartu                                            #
     #        Estonia                                                        #
     #                                                                       #
     #########################################################################
   #+END_SRC


* What's This File About?
** TODO Summary of what this software does <<summary>>
** Literate programming

   This document is a "literate program", i.e., plain text interspersed with actual Julia programming language
   source code.  The source code is extracted ("tangled") into the files [fn:: ~src/DOT_StatsHelp.jl~] and [fn::
   ~tmp/runtests.jl~], from where it can be run etc.

   Literate programming allows me to organize source code, documentation, and tests in a hierarchical document
   structure.


* TODO Progress [1/5]

     + [X] Set up repository [6/6]

       - [X] Create repository
       - [X] Make it Org
       - [X] Set up TOML files
       - [X] Copy content from ShiftRules/SPSA ~Stats~
       - [X] Make version v0.1
       - [X] Register on ~DOT_JuliaPackages~

     + [ ] Make it work, basically [0/2]

       - [ ] Work source code
       - [ ] Maybe some unit tests?

     + [ ] Work the many-runs

     + [ ] Make it type independent,  array or primitive?

     + [ ] Write the [[summary][Summary]]


* Literate Source Code for the Package

** File headers

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

    #+BEGIN_SRC julia :tangle test/runtests.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################

      using Test
      using DOT_StatsHelp
    #+END_SRC


** Generic test based on ~JET.jl~

    #+BEGIN_SRC julia :tangle test/runtests.jl
      using JET
      using JSON # Only for ignoring by JET

      @testset verbose=true "DOT_StatsHelp.jl testing:  via JET.jl" begin
          test_package(DOT_StatsHelp, ignored_modules=(AnyFrameModule(JSON.Parser),) )
      end
    #+END_SRC


** Module definition & imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      module DOT_StatsHelp
    #+END_SRC

    Imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      using DOT_NiceMath            # `‚ãÖ` = `*`  etc
      using DOT_NiceMath.Numbers64  # ‚Ñù, ‚Ñ§, ‚Ñö

      using LinearAlgebra: norm2, norm1, normInf as norm‚àû, norm_sqr as norm¬≤
    #+END_SRC


** Basic types

    The following basic type is made available to the user:

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      export Stats
    #+END_SRC

    An object of this type collects information about the stochastic convergence of the empirical mean of random
    ~Array~ objects to a known(!) limit.

*** The ~Stats~-type with constructor

     Let's define the basic stats collecting type:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       struct Stats{ùêë,V}              # `V` is an integer: the valency of the tensor
           # Input for run
           curr_true_Œº  ::Array{‚Ñù, V} #                      size: `steps`

           # Output of run
           curr_emp_Œº   ::Array{ùêë, V} #                      size: `steps`

           # Overall output
           err2¬≤        ::Array{‚Ñù,2}  # 2-norm of tensor; \
           err1         ::Array{‚Ñù,2}  # 1-norm  ~          | size: `steps` ‚úï `runs`
           err‚àû         ::Array{‚Ñù,2}  # ‚àû-norm  ~         /
           emp_var      ::Vector{ùêë}   #                      size: `runs`

           # Transient data
           _ws           ::Array{ùêë,V} #                      size: `steps`

           # Counters
           ùê¨             ::Ref{Int}   # current step idx (start from 1, as usual)
           ùê´             ::Ref{Int}   # current run  idx (start from 1)
       end
     #+END_SRC

     ~V~ is the valency of the tensor, i.e., ~V~$=1$ for a vectors, ~V~$=2$ for matrices, etc, but also ~V~$=0$ for
     almost [fn:: It's not the same type in Julia.] scalars.

**** Usage

     The user must stick to the following order of instructions for using the ~Stats~ type:

       1. create an object of the type using the [[Constructor][constructor]] below;
       2. start a new run, using the [[start-run][~start_run!()~ function]]
          1. fill run with data using the [[append][~append!()~ function]] repeatedly, once for every "step"
          2. call the [[finalize][~finalize_run!()~ function]] to for tidying up the run
          3. retrieve the stored stats for the run
       3. Goto (2)

     In #4, user can retrieve:

       + The square error over the steps of the run ------- , in the array           ~err2¬≤[end,run]~
       + The 1-norm of the error over the steps ------- , in the array               ~err1[end,run]~
       + The infty-norm of the error over the steps ------- , in the array           ~err‚àû[end,run]~
       + The empirical variance of the estimator (a scalar) for the run ------- , in ~emp_var[run]~

     .... using the following functions:


***** TODO export
***** TODO init s,r




**** Constructor

     The constructor takes the following arguments.

       + The size of the array;
       + The number of steps in each run;
       + The number of runs.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function Stats(sz ::NTuple{V,Int}
                      ;
                      steps :: Int,
                      runs  :: Int       )::Stats{ùêë,V}   where{ùêë<:Real,V}

           curr_true_Œº   = Array{ùêë,V}(undef, sz )
           curr_emp_Œº    = Array{ùêë,V}(undef, sz )        ; curr_emp_Œº   .= ùêë(0)
           _ws           = Array{ùêë,V}(undef, sz )

           err2¬≤         = Array{‚Ñù,2}(undef, steps,runs)
           err1          = Array{‚Ñù,2}(undef, steps,runs)
           err‚àû          = Array{‚Ñù,2}(undef, steps,runs)
           emp_var       = Array{ùêë,1}(undef, runs)       ; emp_var .= ùêë(0)

           return Stats{ùêë,V}(curr_true_Œº,
                             curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var,
                             _ws)
       end
     #+END_SRC

*** TODO Starting a new run: ~start_run~()~ <<start-run>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function start_run!(s ::Stats{ùêë,V}
                           ;
                           true_Œº ::Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}

           ...
               ...
               ...
     #+END_SRC

       + The exact mean ~true_Œº~.

*** Adding data of a step: ~append!()~<<append>>

      * [ ] Double-check calculation of empirical variance

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        import Base: append!
        function append!(s ::Stats{ùêë,V}
                         ;
                         ùê∏ ::Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}

            (;true_Œº, err2¬≤, err1, err‚àû, empirical_Œº, empirical_var, _ws) = s

            @assert length(err2¬≤) == length(err1) ==
                    length(err‚àû)

            n = length(err2¬≤)

            let new_Œº        = _ws
                new_Œº       .= n‚ãÖempirical_Œº/(n+1) .+ ùê∏/(n+1)
                empirical_Œº .= new_Œº
            end

            #
            # Updating `mean‚Ä¶err`
            #
            let err  = _ws
                err .= true_Œº - empirical_Œº

                push!( err2¬≤, norm¬≤(err) )
                push!( err1,  norm1(err) )
                push!( err‚àû,  norm‚àû(err) )
            end #^ let

            #
            # Updating variance
            #
            # We record the simple biased estimate of the empirical variance, and
            # correct it in the `finalize_run!()` function.

            empirical_var[] = n‚ãÖempirical_var[]/(n+1) + norm¬≤( ùê∏ - empirical_Œº )/(n+1)

            nothing;
        end #^ append!()
      #+END_SRC

*** Finalizing a run: ~finalize_run!()~ <<finalize>>

      The ~finalize~()~ function must be called after all data points have been added.  It removes the bias from the
      empirical variance, and makes some debug-checks.

      Moreover, the memory for the true mean, ~true_Œº~, and for the work space, ~_ws~, are released.

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        function finalize!(s ::Stats{ùêë,V}) ::Nothing                  where{ùêë,V}

            (;err2¬≤, err1, err‚àû, empirical_var) = s

            @assert length(err2¬≤) ==
                    length(err1)  == length(err‚àû)

            #
            # Un-bias empirical variance:
            #
            let n=length(err2¬≤)
                empirical_var[] *= (n-1)/n
            end

            nothing;
        end #^ finalize!(::Stats)
      #+END_SRC


** End of module

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      end #^ module SPSA_Shift
    #+END_SRC

    That's it!


* End of the Org File

I'm saying good-bye with some well-meant file-local Emacs variables!

# Local Variables:
# fill-column: 115
# End:
