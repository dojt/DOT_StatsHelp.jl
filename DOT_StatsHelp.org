#+TITLE:  Julia Package That Helps With Statistics For Random Processes
#+AUTHOR: Dirk Oliver Theis, University of Tartu, Estonia
#+EMAIL:  dotheis@ut.ee
#+DATE:   Fri Aug 11 11:19:58 CEST 2023

#+STARTUP: latexpreview
#+STARTUP: show3levels
#+BIBLIOGRAPHY: ../../DOT_LaTeX/dirks.bib
#+PROPERTY: header-args :eval never :comments link :exports code

* Copyright Notice

   The following copyright notice applies to this Org-file, as well as the Julia source file generated from it.

   #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
     #########################################################################
     #                                                                       #
     # Copyright and Licensing Information                                   #
     # -----------------------------------                                   #
     #                                                                       #
     # Copyright lies with the University of Tartu, Estonia, and with the    #
     # author.                                                               #
     #                                                                       #
     # Permission is hereby granted to use and modify the source code under  #
     # the terms of the Apache v2.0 license.                                 #
     #                                                                       #
     #                                                                       #
     # Author:                                                               #
     #                                                                       #
     #        Dirk Oliver Theis                                              #
     #        Assoc. Prof. Theoretical Computer Science                      #
     #        University of Tartu                                            #
     #        Estonia                                                        #
     #                                                                       #
     #########################################################################
   #+END_SRC


* What's This File About?
** TODO Summary of what this software does <<summary>>
** Literate programming

   This document is a "literate program", i.e., plain text interspersed with actual Julia programming language
   source code.  The source code is extracted ("tangled") into the files [fn:: ~src/DOT_StatsHelp.jl~] and [fn::
   ~tmp/runtests.jl~], from where it can be run etc.

   Literate programming allows me to organize source code, documentation, and tests in a hierarchical document
   structure.


* TODO Progress [6/8]

     + [X] Set up repository [6/6]

       - [X] Create repository
       - [X] Make it Org
       - [X] Set up TOML files
       - [X] Copy content from ShiftRules/SPSA ~Stats~
       - [X] Make version v0.1
       - [X] Register on ~DOT_JuliaPackages~

     + [X] Make it work, basically [1/1]

       - [X] Work source code

     + [X] Work the many-runs

     + [X] Make it type independent \\
           Solved by using valency-0 tensors.

     + [X] ~export~

     + [X] Describe the functions

     + [ ] *Fix mistake in emp var calculation !!*

     + [ ] Add unit tests

     + [ ] Write the [[summary][Summary]]

     + [ ] Acknowledge funding: NeQst WP4
           - Also add that to the SPSA paper!


* Literate Source Code for the Package

** File headers

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

    #+BEGIN_SRC julia :tangle test/runtests.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################

      using Test
      using DOT_StatsHelp
    #+END_SRC


** Generic test based on ~JET.jl~

    #+BEGIN_SRC julia :tangle test/runtests.jl
      using JET
      using JSON # Only for ignoring by JET

      @testset verbose=true "DOT_StatsHelp.jl testing:  via JET.jl" begin
          test_package(DOT_StatsHelp, ignored_modules=(AnyFrameModule(JSON.Parser),) )
      end
    #+END_SRC


** Module definition & imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      module DOT_StatsHelp
    #+END_SRC

    Imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      using DOT_NiceMath            # `‚ãÖ` = `*`  etc
      using DOT_NiceMath.Numbers64  # ‚Ñù, ‚Ñ§, ‚Ñö

      using LinearAlgebra: norm2, norm1, normInf as norm‚àû, norm_sqr as norm¬≤
    #+END_SRC


** Main work
*** The type ~Stats{ùêë,V}~

     The following basic type is made available to the user:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export Stats
     #+END_SRC

     An object of this type collects information about the stochastic convergence of the empirical mean of random
     ~Array~ objects to a known(!) limit.

    Let's define it.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       struct Stats{ùêë <: Real, V}              # `V` is an integer: the valency of the tensor
     #+END_SRC

     _Parameters:_

     + ~ùêë~ is the real-number type used for computations.  The user-facing [[stats-constructor][constructor]] defaults this to
       ~NiceMath~'s ~‚Ñù~, which, here is ~Float64~.  If you are worried that cancellations affect the accuracy of
       the overall outcome, use something the package ~DoubleFloats~, or even, if you're patient, ~BigFloats~.

     + ~V~ is a non-negative integer that gives the valency of the tensors that are being averaged, i.e., ~V~ $=1$
       for a vectors, ~V~ $=2$ for matrices, etc.  With ~V~ $=0$ you get scalars.[fn:: Almost -- it's not the same
       type in Julia.]

**** Fields and inner constructor
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            #            Input for run
            curr_true_Œº  ::Array{‚Ñù, V} #                      size: dimension

            #            Output of run
            curr_emp_Œº   ::Array{ùêë, V} #                      size: dimension

            #            Overall output
            err2¬≤        ::Array{‚Ñù,2}  # 2-norm of tensor; \
            err1         ::Array{‚Ñù,2}  # 1-norm  ~          | size: `steps` ‚úï `runs`
            err‚àû         ::Array{‚Ñù,2}  # ‚àû-norm  ~         /
            emp_var      ::Vector{ùêë}   #                      size: `runs`

            #             Work space
            _ws          ::Array{ùêë,V}  #                      size: dimension

            #             Counters
            ùê´            ::Ref{Int}    # index of upcoming run (i.e., 0 ‚™Æ before first run)
            ùê¨            ::Ref{Int}    # index of upcoming step (i.e., 0 ‚™Æ before first step)

            #
            # Convenience constructor -- not for the user
            #
            function
            Stats{ùêë,V}(;
                       curr_true_Œº ::Array{‚Ñù,V}, curr_emp_Œº ::Array{ùêë,V}, emp_var ::Vector{ùêë},
                       err2¬≤ ::Array{‚Ñù,2}, err1 ::Array{‚Ñù,2}, err‚àû ::Array{‚Ñù,2}, _ws ::Array{ùêë,V}) where{ùêë,V}
                new(curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, _ws,
                    0,0)
            end
        end
      #+END_SRC

*** Usage

     The user must stick to the following order of instructions for using the ~Stats~ type:

       1. create an object of the type using the [[stats-constructor][constructor]] below;
       2. For each run:
          1. Start a new run using the [[start][~start_run!()~ function]]
          2. Fill run with data using the [[record][~record_step!()~ function]] repeatedly, once for every step
          3. Call the [[finalize][~finalize_run!()~ function]] to for tidying up the run
          4. Retrieve the stored stats for the run \\
             (the empirical mean of the run is not stored, it's overwritten by the next run)
       3. Repeat, i.e., Goto (2), for all runs
       4. Retrieve the stored stats over all runs.

     In #4, user can retrieve:

       + The square error over the steps of the run, e.g.,           ~err2¬≤(  stats ; run=9, step=27)~
       + The 1-norm of the error over the steps, e.g.,               ~err1(   stats ; run=9, step=27)~
       + The infty-norm of the error over the steps, e.g.,           ~err‚àû(   stats ; run=9, step=27)~
       + The empirical variance of the estimator for the run,, e.g., ~emp_var(stats ; run=9, step=27)~

     For step 2.4, there's also:                                     ~curr_emp_Œº(s)~

     The inquiry functions
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl

       export err2¬≤, err1, err‚àû, emp_var, curr_emp_Œº

     #+END_SRC
     are inconvenient for plotting and whatnot, where direct access to the matrices is better.  The implementations
     of the inquiry functions make clear how that works:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       err2¬≤(  s ::Stats{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err2¬≤[step,run] )
       err1(   s ::Stats{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err1[ step,run] )
       err‚àû(   s ::Stats{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err‚àû[ step,run] )
       emp_var(s ::Stats{ùêë,V}; run ::Int)             where{ùêë,V} = ( @assert 1    ‚â§run ‚â§ s.ùê´[]             ; s.emp_var[run]    )

       curr_emp_Œº(s ::Stats{ùêë,V})                     where{ùêë,V} = ( @assert 1 ‚â§ s.ùê´[]                     ; s.curr_emp_Œº      )
     #+END_SRC

     #+BEGIN_CENTER
     *Warning!*

     Don't forget that the empirical variance is only available after calling [[finalize][~finalize_run!()~]]
     #+END_CENTER

*** User-facing constructor for ~Stats~  <<stats-constructor>>

     The constructor takes the following arguments.

       + The dimension of the underlying tensors, e.g., ~()~ for valency-0 tensors;
       + The number of steps in each run;
       + The number of runs.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function Stats(dimension ::NTuple{V,Int}
                      ;
                      steps :: Int,
                      runs  :: Int,
                      ùêë     :: Type{<:Real} = ‚Ñù)  ::Stats     where{V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           curr_true_Œº   = Array{‚Ñù,V}(undef, dimension )
           curr_emp_Œº    = Array{ùêë,V}(undef, dimension )   ; curr_emp_Œº   .= ùêë(0)
           _ws           = Array{ùêë,V}(undef, dimension )

           err2¬≤         = Array{‚Ñù,2}(undef, steps,runs)
           err1          = Array{‚Ñù,2}(undef, steps,runs)
           err‚àû          = Array{‚Ñù,2}(undef, steps,runs)
           emp_var       = Array{ùêë,1}(undef, runs)         ; emp_var .= ùêë(0)

           return Stats{ùêë,V}( ; curr_true_Œº, curr_emp_Œº,
                                err2¬≤, err1, err‚àû, emp_var,  _ws)
       end
     #+END_SRC

*** Helper functions and integrity check

     The following helper functions are not exported, but can be used by the desperate user.

     _Info about sizes of arrays._

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       valency(        s ::Stats{ùêë,V} ) where{ùêë,V}    = V
       dimension(      s ::Stats{ùêë,V} ) where{ùêë,V}    = size( s.curr_true_Œº )
       numo_stepsruns( s ::Stats{ùêë,V} ) where{ùêë,V}    = size( s.err2¬≤       )
       numo_steps(     s ::Stats{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> first
       numo_runs(      s ::Stats{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> last
     #+END_SRC

     _Data integrity check_ that throws an exception if there's a problem (otherwise returns nothing).

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function _integrity_check(s ::Stats{ùêë,V}) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            @assert size( s.curr_true_Œº ) == dimension(s) == size( s.curr_emp_Œº  )

            let steps  = numo_steps(s),
                runs   = numo_runs(s),
                dim    = dimension(s)

                @assert steps > 1
                @assert runs  ‚â• 1

                @assert 0 ‚â§ s.ùê´[] ‚â§ runs
                @assert 0 ‚â§ s.ùê¨[] ‚â§ steps

                @assert size(     s.err2¬≤       ) == (steps,runs)
                @assert size(     s.err1        ) == (steps,runs)
                @assert size(     s.err‚àû        ) == (steps,runs)
                @assert size(     s.emp_var     ) == (runs,)

                @assert size(     s._ws         ) == dim
            end #^ let
            return nothing
        end
      #+END_SRC

*** Starting a new run: ~start_run!()~ <<start>>

     When a new run starts, the true mean has to be recorded, the indices ùê´ and ùê¨ for run and step, resp., have to
     be set up, and the empirical data has to be initialized.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export start_run!

       function start_run!(s      :: Stats{ùêë,V}
                           ;
                           true_Œº :: Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Working with valency-0 tensors -- aka 0-dimensional arrays
     :PROPERTIES:
     :header-args: :tangle no :session JULIA-1 :eval yes :results output :exports both
     :END:

     The Julia function ~fill()~ can create a valency-0 tensor (0-dimensional array) from a scalar:

     #+BEGIN_SRC julia :tangle no
       a = fill( 3.141 )
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : 3.141

     #+BEGIN_SRC julia :tangle no
       typeof( a )
     #+END_SRC

     #+RESULTS:
     : Array{Float64, 0}

     #+BEGIN_SRC julia :tangle no
       a .- œÄ
     #+END_SRC

     #+RESULTS:
     : -0.0005926535897931018

     #+BEGIN_SRC julia :tangle no
       a .-= œÄ
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : -0.0005926535897931018

**** Implementation of ~start_run!()~
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            _integrity_check(s)


            if    s.ùê´[] > 0         @assert s.ùê¨[] == numo_steps(s)
            else                    @assert s.ùê¨[] == 0               end

            s.ùê´[] += 1            ; @assert s.ùê´[] ‚â§ numo_runs(s)
            s.ùê¨[]  = 0

            @assert size(true_Œº) == dimension(s)

            let ùê´ = s.ùê´[],
                ùê¨ = s.ùê¨[]

                s.curr_true_Œº .= true_Œº
                s.curr_emp_Œº  .= ùêë(0)
                s.emp_var[ùê´]   = ùêë(0)

            end
            nothing;
        end #^ start_run!()
      #+END_SRC

*** Adding data of a step: ~record_step!()~ <<record>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export record_step!

       function record_step!(s ::Stats{ùêë,V}
                             ;
                             ùê∏ ::Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** TODO Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            _integrity_check(s)

            (;curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, _ws) = s


            s.ùê¨[] += 1            ; @assert s.ùê¨[] ‚â§ numo_steps(s)

            let ùê´     = s.ùê´[],
                ùê¨     = s.ùê¨[],
                steps = numo_steps(s)

                curr_emp_Œº  .+= ùê∏/ùêë(steps)
WRONG                emp_var[ùê´]   += norm¬≤( ùê∏ - curr_emp_Œº )/ùêë(steps)  # will be corrected for bias in finalize_run!()


                _ws .= curr_emp_Œº - curr_true_Œº

                err2¬≤[ùê¨,ùê´]  = norm¬≤(_ws)
                err1[ ùê¨,ùê´]  = norm1(_ws)
                err‚àû[ ùê¨,ùê´]  = norm‚àû(_ws)
            end #^ let
            nothing;
        end #^ record_step!()
      #+END_SRC

*** Finalizing a run: ~finalize_run!()~ <<finalize>>

     The ~finalize_run!()~ function must be called after all data points have been added.  It removes the bias
     from the empirical variance.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export finalize_run!

       function finalize_run!(s ::Stats{ùêë,V}) ::Nothing                  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
          _integrity_check(s)

          @assert s.ùê¨[] == numo_steps(s)

          #
          # Un-bias empirical variance:
          #
          s.emp_var[ s.ùê´[] ] *= s.ùê¨[]/ùêë(s.ùê¨[]-1)

          nothing;
        end #^ finalize_run!()
      #+END_SRC


** End of module

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      end #^ module SPSA_Shift
    #+END_SRC

    That's it!


** Tests
*** Set up environment and testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        using DoubleFloats: Double64

        using Base:          abs2     as abs¬≤
        using LinearAlgebra: norm_sqr as norm¬≤, norm2, norm1, normInf as norm‚àû

        using Statistics: mean, var

        @testset verbose=true "DOT_StatsHelp.jl testing: " begin
      #+END_SRC

*** The tests
**** A test

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function qnd_test_0(;runs=11,steps=1001)

            data = 100*randn(steps,runs)

            stats = Stats( () ; steps,runs, #= ùêë=Double64 =#)

            for run = 1:runs

                start_run!(stats ; true_Œº = fill(0.0) )

                for step = 1:steps
                    record_step!(stats ; ùê∏ = fill(data[step,run]) )
                end
                finalize_run!(stats)

                #@test curr_emp_Œº(stats)[]  ‚âà mean( @view data[:,run] )
                @test emp_var(stats;run)   ‚âà var(  @view data[:,run] )

                #@test all(
                #    err2¬≤(stats;run,step) ‚âà abs¬≤(   mean( data[s,run] for s=1:step )   )
                #    for step=1:steps
                #)
                #@test all(
                #    err1(stats;run,step) ‚âà abs(     mean( data[s,run] for s=1:step )   )
                #    for step=1:steps
                #)
                #@test all(
                #    err‚àû(stats;run,step) ‚âà maximum( mean( data[s,run] for s=1:step )   )
                #    for step=1:steps
                #)

            end #^ for run

        end #^ qnd_test_0()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-0 tests" begin
            qnd_test_0()
        end
      #+END_SRC

*** End of testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        end #^ testset
      #+END_SRC


* End of the Org File

I'm saying good-bye with some well-meant file-local Emacs variables!

# Local Variables:
# fill-column: 115
# End:
