#+TITLE:  Julia Package That Helps With Statistics For Random Processes
#+AUTHOR: Dirk Oliver Theis, University of Tartu, Estonia
#+EMAIL:  dotheis@ut.ee
#+DATE:   Fri Aug 11 11:19:58 CEST 2023

#+STARTUP: latexpreview
#+BIBLIOGRAPHY: ../../DOT_LaTeX/dirks.bib
#+PROPERTY: header-args :eval never :comments link :exports code

* Copyright Notice

   The following copyright notice applies to this Org-file, as well as the Julia source file generated from it.

   #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
     #########################################################################
     #                                                                       #
     # Copyright and Licensing Information                                   #
     # -----------------------------------                                   #
     #                                                                       #
     # Copyright lies with the University of Tartu, Estonia, and with the    #
     # author.                                                               #
     #                                                                       #
     # Permission is hereby granted to use and modify the source code under  #
     # the terms of the Apache v2.0 license.                                 #
     #                                                                       #
     #                                                                       #
     # Author:                                                               #
     #                                                                       #
     #        Dirk Oliver Theis                                              #
     #        Assoc. Prof. Theoretical Computer Science                      #
     #        University of Tartu                                            #
     #        Estonia                                                        #
     #                                                                       #
     #########################################################################
   #+END_SRC


* What's This File About?
** TODO Summary of what this software does <<summary>>
** Literate programming

   This document is a "literate program", i.e., plain text interspersed with actual Julia programming language
   source code.  The source code is extracted ("tangled") into the files [fn:: ~src/DOT_StatsHelp.jl~] and [fn::
   ~tmp/runtests.jl~], from where it can be run etc.

   Literate programming allows me to organize source code, documentation, and tests in a hierarchical document
   structure.


* TODO Progress [1/5]

     + [X] Set up repository [6/6]

       - [X] Create repository
       - [X] Make it Org
       - [X] Set up TOML files
       - [X] Copy content from ShiftRules/SPSA ~Stats~
       - [X] Make version v0.1
       - [X] Register on ~DOT_JuliaPackages~

     + [ ] Make it work, basically [0/2]

       - [ ] Work source code
       - [ ] Maybe some unit tests?

     + [ ] Work the many-runs

     + [ ] Make it type independent,  array or primitive?

     + [ ] Write the [[summary][Summary]]


* Literate Source Code for the Package

** File headers

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

    #+BEGIN_SRC julia :tangle test/runtests.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################

      using Test
      using DOT_StatsHelp
    #+END_SRC


** Generic test based on ~JET.jl~

    #+BEGIN_SRC julia :tangle test/runtests.jl
      using JET
      using JSON # Only for ignoring by JET

      @testset verbose=true "DOT_StatsHelp.jl testing:  via JET.jl" begin
          test_package(DOT_StatsHelp, ignored_modules=(AnyFrameModule(JSON.Parser),) )
      end
    #+END_SRC


** Module definition & imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      module DOT_StatsHelp
    #+END_SRC

    Imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      using DOT_NiceMath            # `â‹…` = `*`  etc
      using DOT_NiceMath.Numbers64  # â„, â„¤, â„š

      using LinearAlgebra: norm2, norm1, normInf as normâˆ, norm_sqr as normÂ²
    #+END_SRC


** Basic types

    The following basic type is made available to the user:

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      export Stats
    #+END_SRC

    An object of this type collects information about the stochastic convergence of the empirical mean of random
    ~Array~ objects to a known(!) limit.

*** The ~Stats~-type with constructor

     Let's define the basic stats collecting type:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       struct Stats{ğ‘,V}              # `V` is an integer: the valency of the tensor
           #            Input for run
           curr_true_Î¼  ::Array{â„, V} #                      size: dimension

           #            Output of run
           curr_emp_Î¼   ::Array{ğ‘, V} #                      size: dimension

           #            Overall output
           err2Â²        ::Array{â„,2}  # 2-norm of tensor; \
           err1         ::Array{â„,2}  # 1-norm  ~          | size: `steps` âœ• `runs`
           errâˆ         ::Array{â„,2}  # âˆ-norm  ~         /
           emp_var      ::Vector{ğ‘}   #                      size: `runs`

           #             Work space
           _ws           ::Array{ğ‘,V} #                      size: `steps`

           #             Counters
           ğ«             ::Ref{Int}   # index of upcoming run (i.e., 0 âª® before first run)
           ğ¬             ::Ref{Int}   # index of upcoming step (i.e., 0 âª® before first step)

           function
           Stats{ğ‘,V}(;
                      curr_true_Î¼ ::Array{â„,V}, curr_emp_Î¼ ::Array{ğ‘,V}, emp_var ::Vector{ğ‘},
                      err2Â² ::Vector{â„}, err1 ::Vector{â„}, errâˆ ::Vector{â„}, _ws ::Array{ğ‘,V})
               new(curr_true_Î¼, curr_emp_Î¼, err2Â², err1, errâˆ, emp_var, _ws,
                   0,0)
           end
       end
     #+END_SRC

     ~V~ is the valency of the tensor, i.e., ~V~$=1$ for a vectors, ~V~$=2$ for matrices, etc, but also ~V~$=0$ for
     almost [fn:: It's not the same type in Julia.] scalars.

**** Usage

     The user must stick to the following order of instructions for using the ~Stats~ type:

       1. create an object of the type using the [[Constructor][constructor]] below;
       2. For each run:
          1. Start a new run using the [[start-run][~start_run!()~ function]]
          2. Fill run with data using the [[record-step][~record_step!()~ function]] repeatedly, once for every step
          3. Call the [[finalize][~finalize_run!()~ function]] to for tidying up the run
          4. Retrieve the stored stats for the run \\
             (the empirical mean of the run is not stored, it's overwritten by the next run)
       3. Repeat, i.e., Goto (2), for all runs
       4. Retrieve the stored stats over all runs.

     In #4, user can retrieve:

       + The square error over the steps of the run ------- , in the array           ~err2Â²[end,run]~
       + The 1-norm of the error over the steps ------- , in the array               ~err1[end,run]~
       + The infty-norm of the error over the steps ------- , in the array           ~errâˆ[end,run]~
       + The empirical variance of the estimator (a scalar) for the run ------- , in ~emp_var[run]~

     .... using the following functions:


***** TODO export




**** Constructor

     The constructor takes the following arguments.

       + The dimension of the underlying tensors, e.g., ~(,)~ for valency-0 tensors;
       + The number of steps in each run;
       + The number of runs.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function Stats(dimension ::NTuple{V,Int}
                      ;
                      steps :: Int,
                      runs  :: Int             )  ::Stats{ğ‘,V}     where{ğ‘<:Real,V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           curr_true_Î¼   = Array{ğ‘,V}(undef, dimension )
           curr_emp_Î¼    = Array{ğ‘,V}(undef, dimension )        ; curr_emp_Î¼   .= ğ‘(0)
           _ws           = Array{ğ‘,V}(undef, dimension )

           err2Â²         = Array{â„,2}(undef, steps,runs)
           err1          = Array{â„,2}(undef, steps,runs)
           errâˆ          = Array{â„,2}(undef, steps,runs)
           emp_var       = Array{ğ‘,1}(undef, runs)       ; emp_var .= ğ‘(0)

           return Stats{ğ‘,V}(curr_true_Î¼,
                             curr_emp_Î¼, err2Â², err1, errâˆ, emp_var,
                             _ws)
       end
     #+END_SRC

*** Helper functions

     The following helper functions are not exported, but can be used by the desperate user.

     _Info about sizes of arrays._

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       valency(        s ::Stats{ğ‘,V} ) where{ğ‘,V}    = V
       dimension(      s ::Stats{ğ‘,V} ) where{ğ‘,V}    = size( s.curr_true_Î¼ )
       numo_stepsruns( s ::Stats{ğ‘,V} ) where{ğ‘,V}    = size( s.err2Â²       )
       numo_steps(     s ::Stats{ğ‘,V} ) where{ğ‘,V}    = numo_stepsruns(s) |> first
       numo_runs(      s ::Stats{ğ‘,V} ) where{ğ‘,V}    = numo_stepsruns(s) |> last
     #+END_SRC

     _Data integrity check_ that throws an exception if there's a problem (otherwise returns nothing).

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function _integrity_check(s ::Stats{ğ‘,V}) ::Nothing  where{ğ‘,V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           @assert size( s.curr_true_Î¼ ) == dimension(s) == size( s.curr_emp_Î¼  )

           let steps  = numo_steps(s),
               runs   = numo_runs(s),

               @assert steps > 0
               @assert runs  > 0

               @assert 0 â‰¤ s.ğ« â‰¤ runs
               @assert 0 â‰¤ s.ğ¬ â‰¤ steps

               @assert size(     s.err2Â²       ) == (steps,runs)
               @assert size(     s.err1        ) == (steps,runs)
               @assert size(     s.errâˆ        ) == (steps,runs)
               @assert size(     s.emp_var     ) == (runs,)

               @assert size(     s._ws         ) == (steps,)
           end #^ let
           return nothing
       end
     #+END_SRC

*** Starting a new run: ~start_run~()~ <<start-run>>

     When a new run starts, the true mean has to be recorded, the indices ğ« and ğ¬ for run and step, resp., have to
     be set up, and the empirical data has to be initialized.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export start_run!

       function start_run!(s      :: Stats{ğ‘,V}
                           ;
                           true_Î¼ :: Array{â„,V} ) ::Nothing  where{ğ‘,V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           _integrity_check(s)


           if    s.ğ«[] > 0         @assert s.ğ¬[] == num_steps(s)
           else                    @assert s.ğ¬[] == 0               end

           s.ğ«[] += 1            ; @assert s.ğ«[] < num_runs(s)
           s.ğ¬[]  = 0

           @assert size(true_Î¼) == dimension(s)

           let ğ« = s.ğ«[],
               ğ¬ = s.ğ¬[]

               s.curr_true_Î¼ .= true_Î¼
               s.curr_emp_Î¼  .= ğ‘(0)
               s.emp_var[ğ«]   = ğ‘(0)

           end
           nothing;
       end
     #+END_SRC

*** Adding data of a step: ~record_step!()~<<record-step>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function record_step!(s ::Stats{ğ‘,V}
                             ;
                             ğ¸ ::Array{â„,V} ) ::Nothing  where{ğ‘,V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           _integrity_check(s)

           (;curr_true_Î¼, curr_emp_Î¼, err2Â², err1, errâˆ, emp_var, _ws) = s


           s.ğ¬[] += 1            ; @assert s.ğ¬[] â‰¤ numo_steps(s)

           let ğ«     = s.ğ«[],
               ğ¬     = s.ğ¬[],
               steps = numo_steps(s)

               curr_emp_Î¼  .+= ğ¸/ğ‘(steps)
               emp_var[ğ«]   += normÂ²( ğ¸ - curr_emp_Î¼ )/ğ‘(steps)  # will be corrected for bias in finalize_run!()


               _ws .= curr_emp_Î¼ - curr_true_Î¼

               err2Â²[ğ¬,ğ«]  = normÂ²(_ws)
               err1[ ğ¬,ğ«]  = norm1(_ws)
               errâˆ[ ğ¬,ğ«]  = normâˆ(_ws)
           end #^ let
           nothing;
       end #^ record_step!()
     #+END_SRC

*** Finalizing a run: ~finalize_run!()~ <<finalize>>

     The ~finalize_run!()~ function must be called after all data points have been added.  It removes the bias
     from the empirical variance.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function finalize_run!(s ::Stats{ğ‘,V}) ::Nothing                  where{ğ‘,V}
     #+END_SRC
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
           _integrity_check(s)

           #
           # Un-bias empirical variance:
           #
           steps = numo_steps(s)
           s.emp_var[ğ«] *= (steps-1)/steps

           nothing;
       end #^ finalize_run!()
     #+END_SRC

** End of module

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      end #^ module SPSA_Shift
    #+END_SRC

    That's it!


* End of the Org File

I'm saying good-bye with some well-meant file-local Emacs variables!

# Local Variables:
# fill-column: 115
# End:
