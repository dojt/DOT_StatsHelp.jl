#+TITLE:  Julia Package That Helps With Statistics For Random Processes
#+AUTHOR: Dirk Oliver Theis, University of Tartu, Estonia
#+EMAIL:  dotheis@ut.ee
#+DATE:   Tue Aug 29 18:48:35 CEST 2023

#+STARTUP: latexpreview
#+STARTUP: show2levels
#+BIBLIOGRAPHY: ../../DOT_LaTeX/dirks.bib
#+PROPERTY: header-args :eval never :comments link :exports code
#+SEQ_TODO: TODO DOING CONT In-Tst ARGH ‚ÜòÔ∏è | ToTST DONE

You are here: [[¬§CONTINUE HERE]]

* Copyright Notice

   The following copyright notice applies to this Org-file, as well as the Julia source file generated from it.

   #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
     #########################################################################
     #                                                                       #
     # Copyright and Licensing Information                                   #
     # -----------------------------------                                   #
     #                                                                       #
     # Copyright lies with the University of Tartu, Estonia, and with the    #
     # author.                                                               #
     #                                                                       #
     # Permission is hereby granted to use and modify the source code under  #
     # the terms of the Apache v2.0 license.                                 #
     #                                                                       #
     #                                                                       #
     # Author:                                                               #
     #                                                                       #
     #        Dirk Oliver Theis                                              #
     #        Assoc. Prof. Theoretical Computer Science                      #
     #        University of Tartu                                            #
     #        Estonia                                                        #
     #                                                                       #
     #########################################################################
   #+END_SRC


* ‚ÜòÔ∏è [0/2] What's This Module/Project/File About?
** TODO Summary of what this software does [0/1]               <<summary>>
** CONT High-level usage instructions [1/2]                    <<hl-usage>>
*** TODO General blah blah
*** ToTST Steps and runs
     The fundamental idea is to run a random process for so-and-so many /steps/, collecting information about its
     convergence.  This is repeated for so-and-so-many /runs/, and statistics about the convergence are created.

     The user must stick to the following order of instructions for using the types defined in the module:

       1. create an object of the type using a constructor ([[mp-constructor][mean]], [[max-constructor][max]])
       2. For each run:
          1. Start a new run using the ~start_run!()~ functions ([[mp-start][mean]], [[max-start][max]])
          2. Fill run with data using the ~record_step!()~ function repeatedly, once for every step ([[mp-record][mean]], [[max-record][max]])
          3. Call the ~finalize_run!()~ functions to for tidying up the run [[mp-finalize][(mean]], [[max-finalize][max]])
          4. Retrieve the stats that are overwritten in each run \\
             (e.g., the empirical mean in for mean-estimating processes is kept only for the current run)
       3. Repeat -- i.e., Goto (2) --  for all runs
       4. Retrieve the stored stats over all runs.

** Literate programming

   This document is a "literate program", i.e., plain text interspersed with actual Julia programming language
   source code.  The source code is extracted ("tangled") into the files [fn:: ~src/DOT_StatsHelp.jl~] and [fn::
   ~tmp/runtests.jl~], from where it can be run etc.

   Literate programming allows me to organize source code, documentation, and tests in a hierarchical, text
   document structure.  This makes orientation in the source code so much easier üòä than in a linear source stream.

** Acknowledgments

    The author was partly funded by *Norges Forskningsr√•d* through the [[https://www.sintef.no/en/projects/2022/neqst-quantum-computing-applied-to-industrial-optimization-problems/][NeQst]] project: /Quantum Computing Applied to
    Industrial Optimization Problems,/ project ‚Ññ 332023; part of this software will be utilized within Work Package
    4, /Assessing Quantum Advantage/.


* ‚ÜòÔ∏è TASK LISTS and PROGRESS REPORTS
   <<¬§CONTINUE HERE>>
** [0/1] Generally

     + [ ] Make better docs -- together with exports

** [0/1] Max-approximating process

     + [ ] Make unit tests

** [0/2] Finally, ...

     + [ ] Write the [[summary][Summary]]

     + [ ] Remove this section, [[*TASK LISTS and PROGRESS REPORTS]]


* Setup of the Package and Tests
** File headers

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

    #+BEGIN_SRC julia :tangle test/runtests.jl
      ###########################################################################
      #                                                                         #
      #  THIS IS A MACHINE-GENERATED FILE.  DO NOT EDIT IT.                     #
      #                                                                         #
      #  (The actual source code is in the Org file.)                           #
      #                                                                         #
      ###########################################################################
    #+END_SRC

** Set up testing
**** Importing things
      #+BEGIN_SRC julia :tangle test/runtests.jl
        using  DOT_StatsHelp

        using  Test


        using  DoubleFloats: Double64

        using  LinearAlgebra: norm_sqr as norm2¬≤, norm2, norm1, normInf as norm‚àû

        using  Statistics: mean, var, quantile

        using  DOT_NiceMath
        using  DOT_StatsHelp.Numbers64     # === DOT_NiceMath.Numbers64 -- just making sure we get the same!
      #+END_SRC

**** Generic test based on ~JET.jl~
    #+BEGIN_SRC julia :tangle test/runtests.jl
      using JET
      using JSON        # Only for ignoring by JET
      using JSON3
      using Polynomials # Only for ignoring by JET

      @testset verbose=true "DOT_StatsHelp.jl testing:  via JET.jl" begin
          test_package(DOT_StatsHelp,
                       ignored_modules=(AnyFrameModule(JSON.Parser),
                                        AnyFrameModule(Polynomials),
                                        AnyFrameModule(JSON3),
                                        AnyFrameModule(Base) # Hahaha.
                                        )
                       )
      end
    #+END_SRC

** Module definition, import, and recurrent exports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      module DOT_StatsHelp
    #+END_SRC

    Imports

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      using DOT_NiceMath            # `‚ãÖ` = `*`  etc
      using DOT_NiceMath.Numbers64  # ‚Ñù, ‚Ñ§, ‚Ñö

      using LinearAlgebra: norm2, norm1, normInf as norm‚àû, norm_sqr as norm2¬≤,
                           axpy!, axpby!
    #+END_SRC

    Exports of functions with several methods

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export MeanProc_Full
       export start_run!, record_step!, finalize_run!
       export MeanProc_Full_Storage

       export MeanProc_Qtl
       export start_step!, record_run!, finalize_step!
       export MeanProc_Qtl_Storage

       export  write_JSON, read_JSON_full, read_JSON_qtl
     #+END_SRC


* ‚ÜòÔ∏è Statistics of mean-estimating processes


** Mean estimation with all values for runs
*** Description

    Data points are added with runs as outer loop and steps as inner loop.  The data of all runs is stored.

*** The mean process type: ~MeanProc_Full{ùêë,V}~                   <<¬§MP-full--struct>>

     An object of this exported type collects information about the stochastic convergence of the empirical mean of
     random ~Array~ objects to a known(!) limit.

    Let's define it.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       struct MeanProc_Full{ùêë <: Real, V}              # `V` is an integer: the valency of the tensor
     #+END_SRC

     _Parameters:_

     + ~ùêë~ is the real-number type used for computations.  The user-facing [[mp-constructor][constructor]] defaults this to
       ~NiceMath~'s ~‚Ñù~, which, here is ~Float64~.  If you are worried that cancellations affect the accuracy of
       the overall outcome, use something the package ~DoubleFloats~, or even, if you're patient, ~BigFloats~.

     + ~V~ is a non-negative integer that gives the valency of the tensors that are being averaged, i.e., ~V~ $=1$
       for a vectors, ~V~ $=2$ for matrices, etc.  With ~V~ $=0$ you get scalars.[fn:: Almost -- it's not the same
       type in Julia.]

**** Fields and inner constructor

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        #            Input for run
        curr_true_Œº  ::Array{‚Ñù, V} #                      size: dimension

        #            Output of run
        curr_emp_Œº   ::Array{ùêë, V} #                      size: dimension

        #            Overall output
        err2¬≤        ::Array{‚Ñù,2}  # 2-norm of tensor; \
        err1         ::Array{‚Ñù,2}  # 1-norm  ~          | size: `steps` ‚úï `runs`
        err‚àû         ::Array{‚Ñù,2}  # ‚àû-norm  ~         /
        emp_var      ::Vector{ùêë}   #                      size: `runs`

        #             Work space
        ‚ê£ws          ::Array{ùêë,V}  #                      size: dimension

        #             Counters
        ùê´            ::Ref{Int}    # index of current run (i.e., 0 ‚™Æ before first run)
        ùê¨            ::Ref{Int}    # index of current step (i.e., 0 ‚™Æ before first step)

        #
        # Convenience constructor -- not for the user
        #
        function
        MeanProc_Full{ùêë,V}(;
                   curr_true_Œº ::Array{‚Ñù,V}, curr_emp_Œº ::Array{ùêë,V}, emp_var ::Vector{ùêë},
                   err2¬≤ ::Array{‚Ñù,2}, err1 ::Array{‚Ñù,2}, err‚àû ::Array{‚Ñù,2}, ‚ê£ws ::Array{ùêë,V}) where{ùêë,V}
            new(curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, ‚ê£ws,
                0,0)
        end
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        end
      #+END_SRC

*** Usage

     The [[hl-usage][high-level usage instructios]] are above.  Note that the empirical mean of a run is not stored, it's
     overwritten by the next run.

     There are inquiry functions for retrieving the stats: In #4, user can retrieve:

       + The square error over the steps of the run, e.g.,           ~err2¬≤(  mp ; run=9, step=27)~
       + The 1-norm of the error over the steps, e.g.,               ~err1(   mp ; run=9, step=27)~
       + The infty-norm of the error over the steps, e.g.,           ~err‚àû(   mp ; run=9, step=27)~
       + The empirical variance of the estimator for the run,, e.g., ~emp_var(mp ; run=9, step=27)~

       + For step 2.4, there's also the function:                    ~curr_emp_Œº(mp)~

     The inquiry functions
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl

       export err2¬≤, err1, err‚àû, emp_var, curr_emp_Œº

     #+END_SRC
     are inconvenient for plotting and whatnot, where direct access to the matrices is better.  The implementations
     of the inquiry functions make clear how that works:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       err2¬≤(  s ::MeanProc_Full{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err2¬≤[step,run] )
       err1(   s ::MeanProc_Full{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err1[ step,run] )
       err‚àû(   s ::MeanProc_Full{ùêë,V}; run ::Int, step ::Int) where{ùêë,V} = ( @assert (1,1)‚â§(run,step)‚â§(s.ùê´[],s.ùê¨[]); s.err‚àû[ step,run] )
       emp_var(s ::MeanProc_Full{ùêë,V}; run ::Int)             where{ùêë,V} = ( @assert 1    ‚â§run ‚â§ s.ùê´[]             ; s.emp_var[run]    )

       curr_emp_Œº(s ::MeanProc_Full{ùêë,V})                     where{ùêë,V} = ( @assert 1 ‚â§ s.ùê´[]                     ; s.curr_emp_Œº      )
     #+END_SRC

     #+BEGIN_CENTER
     *Warning!*

     Don't forget that the empirical variance is only available after calling [[mp-finalize][~finalize_run!()~]]
     #+END_CENTER

*** User-facing constructor for ~MeanProc_Full~
     <<mp-constructor>>

     The constructor takes the following arguments.

       + The dimension of the underlying tensors, e.g., ~()~ for valency-0 tensors;
       + The number of steps in each run;
       + The number of runs.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function MeanProc_Full(dimension ::NTuple{V,Int}
                              ;
                              steps :: Int,
                              runs  :: Int,
                              ùêë     :: Type{<:Real} = ‚Ñù)  ::MeanProc_Full     where{V}
     #+END_SRC

**** Implementation

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        curr_true_Œº   = Array{‚Ñù,V}(undef, dimension )
        curr_emp_Œº    = Array{ùêë,V}(undef, dimension )   ; curr_emp_Œº   .= ùêë(0)
        ‚ê£ws           = Array{ùêë,V}(undef, dimension )

        err2¬≤         = Array{‚Ñù,2}(undef, steps,runs)
        err1          = Array{‚Ñù,2}(undef, steps,runs)
        err‚àû          = Array{‚Ñù,2}(undef, steps,runs)
        emp_var       = Array{ùêë,1}(undef, runs)         ; emp_var .= ùêë(0)

        s = MeanProc_Full{ùêë,V}( ; curr_true_Œº, curr_emp_Œº,
                             err2¬≤, err1, err‚àû, emp_var,  ‚ê£ws)
        ‚ê£integrity_check(s)
        return s
      #+END_SRC

      That's it!

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        end #^ MeanProc_Full constructor
      #+END_SRC

*** Helper functions and integrity check

     The following helper functions are not exported, but can be used by the desperate user.

     _Info about sizes of arrays._

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       valency(        s ::MeanProc_Full{ùêë,V} ) where{ùêë,V}    = V
       dimension(      s ::MeanProc_Full{ùêë,V} ) where{ùêë,V}    = size( s.curr_true_Œº )
       numo_stepsruns( s ::MeanProc_Full{ùêë,V} ) where{ùêë,V}    = size( s.err2¬≤       )
       numo_steps(     s ::MeanProc_Full{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> first
       numo_runs(      s ::MeanProc_Full{ùêë,V} ) where{ùêë,V}    = numo_stepsruns(s) |> last
     #+END_SRC

     _Data integrity check_ that throws an exception if there's a problem (otherwise returns nothing).

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function ‚ê£integrity_check(s ::MeanProc_Full{ùêë,V}) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            @assert size( s.curr_true_Œº ) == dimension(s) == size( s.curr_emp_Œº  )

            let steps  = numo_steps(s),
                runs   = numo_runs(s),
                dim    = dimension(s)

                @assert steps > 1
                @assert runs  ‚â• 1

                @assert 0 ‚â§ s.ùê´[] ‚â§ runs
                @assert 0 ‚â§ s.ùê¨[] ‚â§ steps
                @assert s.ùê´[] ‚â• 1 || s.ùê¨[] == 0

                @assert size(     s.err2¬≤       ) == (steps,runs)
                @assert size(     s.err1        ) == (steps,runs)
                @assert size(     s.err‚àû        ) == (steps,runs)
                @assert size(     s.emp_var     ) == (runs,)

                @assert size(     s.‚ê£ws         ) == dim
            end #^ let
            return nothing
        end
      #+END_SRC

*** Starting a new run: ~start_run!()~                            <<mp-start>>

     When a new run starts, the true mean has to be recorded, the indices ùê´ and ùê¨ for run and step, resp., have to
     be set up, and the empirical data has to be initialized.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function start_run!(s      :: MeanProc_Full{ùêë,V}
                           ;
                           true_Œº :: Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Working with valency-0 tensors -- aka 0-dimensional arrays
     :PROPERTIES:
     :header-args: :tangle no :session JULIA-1 :eval yes :results output :exports both
     :END:

     The Julia function ~fill()~ can create a valency-0 tensor (0-dimensional array) from a scalar:

     #+BEGIN_SRC julia :tangle no
       a = fill( 3.141 )
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : 3.141

     #+BEGIN_SRC julia :tangle no
       typeof( a )
     #+END_SRC

     #+RESULTS:
     : Array{Float64, 0}

     #+BEGIN_SRC julia :tangle no
       a .- œÄ
     #+END_SRC

     #+RESULTS:
     : -0.0005926535897931018

     #+BEGIN_SRC julia :tangle no
       a .-= œÄ
     #+END_SRC

     #+RESULTS:
     : 0-dimensional Array{Float64, 0}:
     : -0.0005926535897931018

**** Implementation of ~start_run!()~
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            ‚ê£integrity_check(s)


            if    s.ùê´[] > 0         @assert s.ùê¨[] == numo_steps(s)
            else                    @assert s.ùê¨[] == 0               end

            s.ùê´[] += 1            ; @assert s.ùê´[] ‚â§ numo_runs(s)
            s.ùê¨[]  = 0

            @assert size(true_Œº) == dimension(s)

            let ùê´ = s.ùê´[],
                ùê¨ = s.ùê¨[]

                s.curr_true_Œº .= true_Œº
                s.curr_emp_Œº  .= ùêë(0)
                s.emp_var[ùê´]   = ùêë(0)

            end
            nothing;
        end #^ start_run!()
      #+END_SRC

*** Adding data of a step: ~record_step!()~
     <<mp-record>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function record_step!(s ::MeanProc_Full{ùêë,V}
                             ;
                             ùê∏ ::Array{‚Ñù,V} ) ::Nothing  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        ‚ê£integrity_check(s)

        (;curr_true_Œº, curr_emp_Œº, err2¬≤, err1, err‚àû, emp_var, ‚ê£ws) = s


        s.ùê¨[] += 1            ; @assert s.ùê¨[] ‚â§ numo_steps(s)

        let ùê´     = s.ùê´[],
            ùê¨     = s.ùê¨[],
            steps = numo_steps(s)

            #
            # Note order between emp var and emp Œº
            #
            # emp_var[ùê´]   = (ùê¨-1) ‚ãÖ emp_var[ùê´]  / ùê¨    +   (ùê¨-1) ‚ãÖ norm2¬≤( curr_emp_Œº - ùê∏ ) / ùê¨¬≤
            # curr_emp_Œº  .= (ùê¨-1) ‚ãÖ curr_emp_Œº / ùê¨   +   ùê∏ / ùê¨

            ‚ê£ws         .= curr_emp_Œº
            axpby!(-1/ùê¨, ùê∏,  1/ùê¨, ‚ê£ws)
            emp_var[ùê´]   = (ùê¨-1) ‚ãÖ (   emp_var[ùê´]  / ùê¨    +   norm2¬≤( ‚ê£ws )   )
                          # will be corrected for bias in finalize_run!()

            axpby!( 1/ùê¨, ùê∏, (ùê¨-1)/ùê¨, curr_emp_Œº)

            #
            # Errors
            #
            ‚ê£ws         .= curr_emp_Œº - curr_true_Œº

            err2¬≤[ùê¨,ùê´]   = norm2¬≤(‚ê£ws)
            err1[ ùê¨,ùê´]   = norm1(‚ê£ws)
            err‚àû[ ùê¨,ùê´]   = norm‚àû(‚ê£ws)
        end #^ let
        nothing;
        end #^ record_step!()
      #+END_SRC

*** Finalizing a run: ~finalize_run!()~                           <<mp-finalize>>

     The ~finalize_run!()~ function must be called after all data points have been added.  It removes the bias
     from the empirical variance.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function finalize_run!(s ::MeanProc_Full{ùêë,V}) ::Nothing                  where{ùêë,V}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            ‚ê£integrity_check(s)

            @assert s.ùê¨[] == numo_steps(s)

            #
            # Un-bias empirical variance:
            #
            let ùê´     = s.ùê´[],
                ùê¨     = s.ùê¨[]

                s.emp_var[ ùê´ ] *= ùê¨ / ùêë(ùê¨-1)
            end
            nothing;
        end #^ finalize_run!()
      #+END_SRC
*** Storage and JSON export-import
**** Storage struct

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        @kwdef struct MeanProc_Full_Storage{V}
            dim          ::NTuple{V,Int}
            steps_runs   ::Tuple{Int,Int}

            curr_true_Œº  ::Array{‚Ñù,1} # was: V
            curr_emp_Œº   ::Array{‚Ñù,1} #      V
            err2¬≤        ::Array{‚Ñù,1} #      2
            err1         ::Array{‚Ñù,1} #      2
            err‚àû         ::Array{‚Ñù,1} #      2

            emp_var      ::Vector{‚Ñù}
        end
      #+END_SRC

***** Constructor: ~MeanProc_Full~ to ~MeanProc_Full_Storage~

       #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
         function MeanProc_Full_Storage(mp ::MeanProc_Full{‚Ñù,V}) ::MeanProc_Full_Storage{V} where{V}
             dim                         = size( mp.curr_true_Œº )
             steps_runs ::Tuple{Int,Int} = size( mp.err2¬≤       )

             return MeanProc_Full_Storage{V}(;
                                    dim         = dim,
                                    steps_runs  = steps_runs,
                                    curr_true_Œº = reshape(mp.curr_true_Œº , (length(mp.curr_true_Œº),) ),
                                    curr_emp_Œº  = reshape(mp.curr_emp_Œº  , (length(mp.curr_emp_Œº ),) ),
                                    err2¬≤       = reshape(mp.err2¬≤       , (length(mp.err2¬≤      ),) ),
                                    err1        = reshape(mp.err1        , (length(mp.err1       ),) ),
                                    err‚àû        = reshape(mp.err‚àû        , (length(mp.err‚àû       ),) ),
                                    emp_var     =         mp.emp_var
                                    )
         end
       #+END_SRC

***** Constructor: ~MeanProc_Full_Storage~ to ~MeanProc_Full~

       #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
         function MeanProc_Full(mpio ::MeanProc_Full_Storage{V}) ::MeanProc_Full{‚Ñù,V}    where{V}
             return MeanProc_Full{‚Ñù,V}(;
                                  curr_true_Œº = reshape(mpio.curr_true_Œº , mpio.dim       ),
                                  curr_emp_Œº  = reshape(mpio.curr_emp_Œº  , mpio.dim       ),
                                  err2¬≤       = reshape(mpio.err2¬≤       , mpio.steps_runs),
                                  err1        = reshape(mpio.err1        , mpio.steps_runs),
                                  err‚àû        = reshape(mpio.err‚àû        , mpio.steps_runs),
                                  emp_var     =         mpio.emp_var,
                                  ‚ê£ws         = Array{‚Ñù,V}( undef,  ((0 for j=1:V)...,)  )
                                  )
         end
       #+END_SRC

**** JSON-IO functions

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        using JSON3
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        function write_JSON(mp ::MeanProc_Full{‚Ñù,V}) ::String      where{V}
            return JSON3.write( MeanProc_Full_Storage( mp ) )
        end
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        function read_JSON_full(json ::AbstractString; V ::Int) ::MeanProc_Full
            return MeanProc_Full( JSON3.read(json, MeanProc_Full_Storage{V}) )
        end
      #+END_SRC

*** Tests for the all-vals mean process
**** Set up testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset verbose=true "DOT_StatsHelp.jl testing: Test MeanProc_Full{}" begin
      #+END_SRC

**** Test with valency 0

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_0(;runs=1:10,steps=2:4:20)
            for ùêë ‚àà (Double64,Float64)
                for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                    data = 100*randn(curr_steps,curr_runs)

                    mp = MeanProc_Full( () ; steps=curr_steps, runs=curr_runs, ùêë)

                    for run = 1:curr_runs

                        start_run!(mp ; true_Œº = fill(0.0) )

                        for step = 1:curr_steps
                            record_step!(mp ; ùê∏ = fill(data[step,run]) )
                            @test curr_emp_Œº(mp)[]  ‚âà mean( @view data[1:step,run] )
                        end
                        finalize_run!(mp)

                        @test emp_var(mp;run)         ‚âà var(  @view data[:,run] )

                        for step=1:curr_steps
                            @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> abs¬≤
                        end
                        @test all(
                            err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> abs
                            for step=1:curr_steps
                                )
                        @test all(
                            err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> abs
                        for step=1:curr_steps
                            )

                    end #^ for run

                    if ùêë == Float64
                        jsonstr = write_JSON(mp)
                        mp2     = read_JSON_full(jsonstr;V=0)

                        @test mp.curr_true_Œº  == mp2.curr_true_Œº
                        @test mp.curr_emp_Œº   == mp2.curr_emp_Œº
                        @test mp.err2¬≤        == mp2.err2¬≤
                        @test mp.err1         == mp2.err1
                        @test mp.err‚àû         == mp2.err‚àû
                        @test mp.emp_var      == mp2.emp_var
                    end

                end #^ for curr_...
            end #^ for ùêë
        end #^ test__meanestim_0()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-0 tests" begin
            test__meanestim_0()
        end
      #+END_SRC

**** Test with valency 1

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_1(;runs=1:3:9,steps=2:5:12)
            for ùêë ‚àà (Double64,Float64)
                for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                    dim  = 31

                    data = [ randn(dim) for s=1:curr_steps, r=1:curr_runs ]

                    mp = MeanProc_Full( (dim,) ; steps=curr_steps, runs=curr_runs, ùêë)

                    for run = 1:curr_runs

                        start_run!(mp ; true_Œº = zeros(31) )

                        for step = 1:curr_steps
                            record_step!(mp ; ùê∏ = data[step,run] )
                            @test curr_emp_Œº(mp)  ‚âà mean( @view data[1:step,run] )
                        end
                        finalize_run!(mp)

                        @test emp_var(mp;run)         ‚âà var( @view data[:,run] ) |> norm1 # Julia `var` returns array

                        for step=1:curr_steps
                            @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> norm2¬≤
                        end
                        @test all(
                            err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm1
                            for step=1:curr_steps
                        )
                        @test all(
                            err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm‚àû
                            for step=1:curr_steps
                        )

                    end #^ for run

                    if ùêë == Float64
                        jsonstr = write_JSON(mp)
                        mp2     = read_JSON_full(jsonstr;V=1)

                        @test mp.curr_true_Œº  == mp2.curr_true_Œº
                        @test mp.curr_emp_Œº   == mp2.curr_emp_Œº
                        @test mp.err2¬≤        == mp2.err2¬≤
                        @test mp.err1         == mp2.err1
                        @test mp.err‚àû         == mp2.err‚àû
                        @test mp.emp_var      == mp2.emp_var
                    end

                end #^ for curr_...
            end #^ for ùêë
        end #^ test__meanestim_1()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-1 tests" begin
            test__meanestim_1()
        end
      #+END_SRC

**** Test with valency 2

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_2(;runs=1:3:9,steps=2:5:12)
            for ùêë ‚àà (Double64,Float64)
                for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                    sz  = (7,13)

                    data = [ randn(sz) for s=1:curr_steps, r=1:curr_runs ]

                    mp = MeanProc_Full( (sz) ; steps=curr_steps, runs=curr_runs, ùêë)

                    for run = 1:curr_runs

                        start_run!(mp ; true_Œº = zeros(sz) )

                        for step = 1:curr_steps
                            record_step!(mp ; ùê∏ = data[step,run] )
                            @test curr_emp_Œº(mp)  ‚âà mean( @view data[1:step,run] )
                        end
                        finalize_run!(mp)

                        @test emp_var(mp;run)         ‚âà var( @view data[:,run] ) |> norm1 # Julia `var` returns array

                        for step=1:curr_steps
                            @test  err2¬≤(mp;run,step) ‚âà mean( data[1:step,run] ) |> norm2¬≤
                        end
                        @test all(
                            err1(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm1
                            for step=1:curr_steps
                        )
                        @test all(
                            err‚àû(mp;run,step)         ‚âà mean( data[1:step,run] ) |> norm‚àû
                            for step=1:curr_steps
                        )

                    end #^ for run

                    if ùêë == Float64
                        jsonstr = write_JSON(mp)
                        mp2     = read_JSON_full(jsonstr;V=2)

                        @test mp.curr_true_Œº  == mp2.curr_true_Œº
                        @test mp.curr_emp_Œº   == mp2.curr_emp_Œº
                        @test mp.err2¬≤        == mp2.err2¬≤
                        @test mp.err1         == mp2.err1
                        @test mp.err‚àû         == mp2.err‚àû
                        @test mp.emp_var      == mp2.emp_var
                    end

                end #^ for curr_...
            end #^ for ùêë
        end #^ test__meanestim_1()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset "Valency-2 tests" begin
            test__meanestim_2()
        end
      #+END_SRC

**** End of testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        end #^ testset
      #+END_SRC


** ‚ÜòÔ∏è [0/1] Mean estimation with a quantile over runs
*** Description

    Data points are added with runs as /inner/ loop and steps as /outer/ loop.  Over the runs, only a given
    quantile is stored.

    Data points are vanilla real numbers (i.e., valency-0 tensors, but not of tensor type).

*** The type ~MeanProc_Qtl{ùêë}~

     We will define the type of quantiles; first a convenient shortcut:

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       const ‚Ñù¬≤ = Tuple{‚Ñù,‚Ñù}
     #+END_SRC

     The following basic type is exported:

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       struct MeanProc_Qtl{ùêë <: Real}
     #+END_SRC

     See [[¬§MP-full--struct][text for ~MeanProc_Full~ for]] explanations about the parameters ~ùêë~; this type stores only real numbers
     (i.e., valency-0 tensors).

**** Fields and inner constructor

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        numo_steps      ::Int         #                      no need-to-know, just pest control

        #               Input for run
        Œ¥               ::‚Ñù           #                      the quantile
        true_Œº          ::‚Ñù           #                      constant over runs!
        Œµ‚ÇÄ              ::‚Ñù           # correction for `true_Œº` close to 0

        #               Result of step
        curr_emp_Œº      ::Vector{ùêë}   #                      length: `runs`
        err             ::Vector{‚Ñù}   # relative error       length: `runs`
        emp_var         ::Vector{ùêë}   #                      length: `runs`

        #               Overall output
        err_quants      ::Vector{‚Ñù}   # the quantiles        length: `steps`
        err_minmax      ::Vector{‚Ñù¬≤}  #                      length: `steps`
        emp_var_minmax  ::Vector{‚Ñù¬≤}  #                      length: `steps`

        #               Work space over steps
        ‚ê£œÄ              ::Vector{Int} # permutation          length: `runs`

        #               Counters
        ùê´               ::Ref{Int}    # index of current run (i.e., 0 ‚™Æ before first run)
        ùê¨               ::Ref{Int}    # index of current step (i.e., 0 ‚™Æ before first step)

        <<""" Struct MeanProc_Qtl convenience constructor """>> ;
      #+END_SRC

      That's it.

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        end #^ struct MeanProc_Qtl
      #+END_SRC

***** Convenience constructor -- *not* for the user!

       This only adds the 0-inits for the references ùê´, ùê¨.

       #+CAPTION: ¬´ ~Struct MeanProc_Qtl convenience constructor~ ¬ª
       #+NAME:   """ Struct MeanProc_Qtl convenience constructor """
       #+BEGIN_SRC julia   :tangle no               :noweb no-export :noweb-prefix no
         function
             MeanProc_Qtl{ùêë}(  Œ¥ ::‚Ñù
                               ;
                               numo_steps ::Int, true_Œº ::‚Ñù, Œµ‚ÇÄ ::‚Ñù,
                               curr_emp_Œº ::Vector{ùêë}, emp_var ::Vector{ùêë}, err ::Vector{‚Ñù}, ‚ê£œÄ ::Vector{Int},
                               err_quants ::Vector{‚Ñù}, err_minmax ::Vector{‚Ñù¬≤}, emp_var_minmax ::Vector{‚Ñù¬≤}
                            ) where{ùêë}

             new{ùêë}(numo_steps,
                    Œ¥, true_Œº, Œµ‚ÇÄ,
                    curr_emp_Œº, err, emp_var,
                    err_quants, err_minmax, emp_var_minmax,
                    ‚ê£œÄ,
                    0,0)
         end
         #+END_SRC

*** TODO Usage
*** User-facing constructor

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       function MeanProc_Qtl(Œ¥      :: ‚Ñù
                             ;
                             true_Œº :: ‚Ñù,
                             runs   :: Int,
                             steps  :: Int,
                             ùêë      :: Type{<:Real} = ‚Ñù,
                             Œµ‚ÇÄ     :: ‚Ñù            = 1e-6)
     #+END_SRC

**** Implementation

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        @assert 0 < Œ¥ < 1
        @assert isfinite(true_Œº)
        @assert runs ‚â• 2
        @assert 0 ‚â§ Œµ‚ÇÄ < 0.1

        curr_emp_Œº     = zeros( ùêë,          runs) ::Vector{ùêë}
        emp_var        = zeros( ùêë,          runs) ::Vector{ùêë}
        err            = Vector{‚Ñù  }(undef, runs)
        ‚ê£œÄ             = collect(1:runs)


        err_quants     = ‚Ñù[]  ; sizehint!(err_quants    ,steps)
        err_minmax     = ‚Ñù¬≤[] ; sizehint!(err_minmax    ,steps)
        emp_var_minmax = ‚Ñù¬≤[] ; sizehint!(emp_var_minmax,steps)

        s = MeanProc_Qtl{ùêë}(Œ¥ ; Œµ‚ÇÄ, numo_steps=steps, true_Œº,
                            curr_emp_Œº, emp_var, err, ‚ê£œÄ,
                            err_quants, err_minmax, emp_var_minmax)
        ‚ê£integrity_check(s)
        return s
      #+END_SRC

      That's it!

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        end #^ MeanProc_Qtl constructor
      #+END_SRC

*** Helper functions and integrity check

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       numo_runs( s ::MeanProc_Qtl{ùêë} ) where{ùêë}    = length(s.curr_emp_Œº)
       numo_steps(s ::MeanProc_Qtl{ùêë} ) where{ùêë}    = s.numo_steps
     #+END_SRC

     _Data integrity check_ that throws an exception if there's a problem (otherwise returns nothing).

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function ‚ê£integrity_check(s ::MeanProc_Qtl{ùêë}) ::Nothing  where{ùêë}
     #+END_SRC

**** Implementation
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        @assert isfinite( s.true_Œº )
        @assert 0 < s.Œ¥  < 1
        @assert 0 ‚â§ s.Œµ‚ÇÄ < 0.1

        let runs   = numo_runs(s)
            steps  = numo_steps(s)

            @assert runs  ‚â• 2

            @assert 0 ‚â§ s.ùê´[] ‚â§ runs
            @assert 0 ‚â§ s.ùê¨[] ‚â§ steps
            @assert s.ùê¨[] ‚â• 1 || s.ùê´[] == 0

            @assert size( s.curr_emp_Œº     ) == (runs,)
            @assert size( s.err            ) == (runs,)
            @assert size( s.emp_var        ) == (runs,)
            @assert size( s.‚ê£œÄ             ) == (runs,)

            @assert size( s.err_quants     ) ==
                    size( s.err_minmax     ) ==
                    size( s.emp_var_minmax )

            @assert (s.ùê¨[]-1,) ‚â§ size(s.err_quants) ‚â§ (s.ùê¨[],) # ??????????????????????????

        end #^ let
        return nothing
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        end #^ ‚ê£integrity_check(::MeanProc_Qtl)
      #+END_SRC

*** Starting a new step: ~start_step!()~

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       function start_step!(s ::MeanProc_Qtl{ùêë}) ::Nothing        where{ùêë}

           ‚ê£integrity_check(s)


           if    s.ùê¨[] > 0         @assert s.ùê´[] == numo_runs(s)
           else                    @assert s.ùê´[] == 0               end

           s.ùê¨[] += 1            ; @assert s.ùê¨[] ‚â§ numo_steps(s)
           s.ùê´[]  = 0

           nothing;
       end #^ start_run!()
     #+END_SRC

*** Adding a data point: ~record_run!()~

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       function record_run!( s ::MeanProc_Qtl{ùêë}
                             ;
                             ùê∏ ::‚Ñù              ) ::Nothing  where{ùêë}

           ‚ê£integrity_check(s)

           @assert isfinite(ùê∏)
           @assert s.ùê¨[] ‚â• 1
           @assert s.ùê´[] < numo_runs(s)

           let
               ( ;
                 Œ¥, true_Œº,
                 curr_emp_Œº,
                 err,
                 emp_var,
                 ùê´, ùê¨          ) = s

               ùê´[] += 1

               ùëü = ùê´[]
               ùë† = ùê¨[]

               # new_unbiased_emp_var =
               # = [  (ùê¨-1) ‚ãÖ old_biased_emp_var  / ùê¨        +   (ùê¨-1) ‚ãÖ | curr_emp_Œº - ùê∏ |¬≤ / ùê¨¬≤  ]‚ãÖùê¨/(ùê¨-1)
               # =            old_biased_emp_var             +           | curr_emp_Œº - ùê∏ |¬≤ / ùê¨
               # =          old_unbiased_emp_var‚ãÖ(ùê¨-2)/(ùê¨-1) +           | curr_emp_Œº - ùê∏ |¬≤ / ùê¨
               let old_Œº = curr_emp_Œº[ùëü]

                   emp_var[ùëü] =
                       if      ùë† == 1      ùêë(0)
                       else
                           old_biased_emp_var  = emp_var[ùëü] ‚ãÖ (ùë†-2)/ùêë(ùë†-1)
                           old_biased_emp_var  +  abs¬≤(old_Œº ‚àí ùê∏) / ùë†
                       end
               end #^ let


               curr_emp_Œº[ùëü] = ( (ùë†-1)‚ãÖcurr_emp_Œº[ùëü] + ùê∏ ) / ùë†


               let ùõ• = abs( curr_emp_Œº[ùëü] ‚àí true_Œº )

                   err[ùëü] = ùõ• / ( abs(true_Œº) + s.Œµ‚ÇÄ )

               end
           end #^ let
           nothing;
       end #^ record_run!()
     #+END_SRC

*** Finalizing a step: ~finalize_step!()~

     This version of ~finalize...()~ returns the quantile.
     #+BEGIN_CENTER
     *WARNING!* \\
     This function uses an undocumented Julia library function:  ~Statistics._quantile()~!
     #+END_CENTER

     #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
       <<""" Helper-type for concatenating vectors err and ‚ê£œÄ """>> ;

       using Statistics: _quantile

       function finalize_step!(s ::MeanProc_Qtl{ùêë}) ::‚Ñù     where{ùêë}

           ‚ê£integrity_check(s)


           let
               runs              = numo_runs(s)
               ( ;
                 Œ¥, true_Œº,
                 curr_emp_Œº,
                 err,
                 emp_var,
                 ‚ê£œÄ,
                 ùê´, ùê¨          ) = s


               push!(s.err_quants    ,
                     let lo = floor(Int,   Œ¥‚ãÖruns ),
                         hi = ceil( Int, 1+Œ¥‚ãÖruns )
                         sortperm!( ‚ê£œÄ, err  ;  alg = PartialQuickSort( lo:hi ) )
                         err_‚ê£œÄ = ‚ê£Concat_Vect(err,‚ê£œÄ)
                         _quantile(err_‚ê£œÄ, Œ¥)
                     end
                     )

               push!(        s.err_minmax             ,
                       extrema(err)                    )

               push!(        s.emp_var_minmax         ,
                       extrema(emp_var) |> Tuple{‚Ñù,‚Ñù}  )
           end #^ let

           ‚ê£integrity_check(s)

           return s.err_quants[end]
       end #^ finalize_step!()
     #+END_SRC

     #+CAPTION: ¬´ ~Helper-type for concatenating vectors err and ‚ê£œÄ~ ¬ª
     #+NAME:   """ Helper-type for concatenating vectors err and ‚ê£œÄ """
     #+BEGIN_SRC julia   :tangle no               :noweb no-export :noweb-prefix no
       struct ‚ê£Concat_Vect <: AbstractVector{‚Ñù}
           val ::Vector{‚Ñù}
           idx ::Vector{Int}
       end

       import Base: size, length, getindex
       size(     cv ::‚ê£Concat_Vect             ) = (length(cv.idx),)
       length(   cv ::‚ê£Concat_Vect             ) = length(cv.idx)
       getindex( cv ::‚ê£Concat_Vect, i ::Integer) = cv.val[cv.idx[i]]
     #+END_SRC

*** Storage and JSON export-import
**** Storage struct

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        @kwdef struct MeanProc_Qtl_Storage
            steps_runs      ::Tuple{Int,Int}

            Œ¥               ::‚Ñù
            Œµ‚ÇÄ              ::‚Ñù
            true_Œº          ::‚Ñù

            curr_emp_Œº      ::Vector{‚Ñù}   #    length `runs`
            err             ::Vector{‚Ñù}   #    length `runs`
            emp_var         ::Vector{‚Ñù}   #    length `runs`

            err_quants      ::Vector{‚Ñù}   #    length: `steps`
            err_minmax      ::Vector{‚Ñù¬≤}  #    length: `steps`
            emp_var_minmax  ::Vector{‚Ñù¬≤}  #    length: `steps`
        end
      #+END_SRC

***** Constructor: ~MeanProc_Qtl~ to ~MeanProc_Qtl_Storage~

       #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
         function MeanProc_Qtl_Storage(mp ::MeanProc_Qtl{‚Ñù}) ::MeanProc_Qtl_Storage
             steps_runs ::Tuple{Int,Int} = (numo_steps(mp),numo_runs(mp))

             return MeanProc_Qtl_Storage(;
                                    steps_runs     = steps_runs,
                                    Œ¥              = mp.Œ¥,
                                    Œµ‚ÇÄ             = mp.Œµ‚ÇÄ,
                                    true_Œº         = mp.true_Œº,

                                    curr_emp_Œº     = mp.curr_emp_Œº,
                                    err            = mp.err,
                                    emp_var        = mp.emp_var,

                                    err_quants     = mp.err_quants,
                                    err_minmax     = mp.err_minmax,
                                    emp_var_minmax = mp.emp_var_minmax
                                    )
         end
       #+END_SRC

**** JSON-IO functions

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        using JSON3
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        function write_JSON(mp ::MeanProc_Qtl{‚Ñù}) ::String
            return JSON3.write( MeanProc_Qtl_Storage( mp ) )
        end
      #+END_SRC

      #+BEGIN_SRC julia   :tangle src/DOT_StatsHelp.jl   :noweb no-export :noweb-prefix no
        function read_JSON_qtl(json ::AbstractString) ::MeanProc_Qtl_Storage
            mpio = JSON3.read(json, MeanProc_Qtl_Storage)
            (steps,runs) = mpio.steps_runs
            @assert runs  == length(mpio.curr_emp_Œº    )
            @assert runs  == length(mpio.err           )
            @assert runs  == length(mpio.emp_var       )
            @assert steps == length(mpio.err_quants    )
            @assert steps == length(mpio.err_minmax    )
            @assert steps == length(mpio.emp_var_minmax)
            return mpio
        end
      #+END_SRC

*** Tests for the quantile mean process
**** Set up testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset verbose=true "DOT_StatsHelp.jl testing: Test MeanProc_Qtl{}" begin
      #+END_SRC

**** The test

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__meanestim_qtl(;runs=10:71:400,steps=4:4:20)

            Œ¥  = 0.123

            for Œµ‚ÇÄ ‚àà (1e-3, 1e-7)
                for true_Œº ‚àà (1.0, 1e-10)
                    for ùêë ‚àà (Double64,Float64)
                        for (curr_runs,curr_steps) in Iterators.product(runs,steps)

                            data = ones(curr_steps,curr_runs)/true_Œº + 100*randn(curr_steps,curr_runs)
                            Œº    = [ mean( @view data[1:step,run]   )  for step=1:curr_steps, run=1:curr_runs ]
                            vari = [ var(  @view data[1:step,run]   )  for step=1:curr_steps, run=1:curr_runs ]
                            Œî    = abs.( Œº .‚àí true_Œº )
                            rerr = Œî ./( true_Œº + Œµ‚ÇÄ )

                            pcnt = [ quantile((@view rerr[step,:]),Œ¥)  for step=1:curr_steps ]
                            erex = [ extrema(  @view rerr[step,:]   )  for step=1:curr_steps ]
                            varex= [ extrema(  @view vari[step,:]   )  for step=1:curr_steps ]

                            mp = MeanProc_Qtl(Œ¥
                                              ;
                                              true_Œº, Œµ‚ÇÄ,
                                              runs   = curr_runs,
                                              steps  = curr_steps,
                                              ùêë)
                            for step = 1:curr_steps

                                start_step!(mp)

                                for run = 1:curr_runs

                                    record_run!(mp ; ùê∏ = data[step,run] )

                                    @test mp.curr_emp_Œº[ mp.ùê´[]] ‚âà Œº[   step,run]
                                    @test mp.err[        mp.ùê´[]] ‚âà rerr[step,run]
                                    if step ‚â• 2
                                        @test mp.emp_var[mp.ùê´[]] ‚âà vari[step,run]    rtol=1e-4
                                    end
                                end #^ for (runs)

                                finalize_step!(mp)

                                @test mp.err_quants[step] ‚âà pcnt[step]
                                @test all( a‚âàb
                                           for (a,b) ‚àà zip(mp.err_minmax[step],erex[step])
                                         )
                                if step ‚â• 2
                                    @test first(mp.emp_var_minmax[step]) ‚âà first(varex[step])    rtol=1e-3
                                    @test last( mp.emp_var_minmax[step]) ‚âà last( varex[step])    rtol=1e-3
                                end
                            end #^ for (steps)

                            @test mp.numo_steps == curr_steps
                            @test mp.ùê¨[]        == curr_steps
                            @test mp.ùê´[]        == curr_runs


                            if ùêë == Float64
                                jsonstr  = write_JSON(mp)
                                mpio     = read_JSON_qtl(jsonstr)

                                @test mp.numo_steps     == first( mpio.steps_runs )
                                @test length(mp.err)    == last(  mpio.steps_runs )
                                @test mp.Œ¥              == mpio.Œ¥
                                @test mp.Œµ‚ÇÄ             == mpio.Œµ‚ÇÄ
                                @test mp.true_Œº         == mpio.true_Œº
                                @test mp.curr_emp_Œº     == mpio.curr_emp_Œº
                                @test mp.err            == mpio.err
                                @test mp.emp_var        == mpio.emp_var
                                @test mp.err_quants     == mpio.err_quants
                                @test mp.err_minmax     == mpio.err_minmax
                                @test mp.emp_var_minmax == mpio.emp_var_minmax
                            end
                        end #^ for curr_...
                    end #^ for ùêë
                end #^ for true_Œº
            end #^ for Œµ‚ÇÄ
        end #^ test__meanestim_0()
      #+END_SRC

      Run it:

      #+BEGIN_SRC julia :tangle test/runtests.jl
        test__meanestim_qtl()
      #+END_SRC

**** End of testset

      #+BEGIN_SRC julia :tangle test/runtests.jl
        end #^ testset
      #+END_SRC


* CONT [0/9] Statistics of max-approximating processes
** In-Tst Helper-functions for frequencies
*** Description

      The function ~‚ê£xtiles_count!()~ records frequencies: A call to the function [[‚ê£xtiles_count!()][~‚ê£xtiles_count!()~]] registers a
      data point by increasing the frequency for the interval $\left]\pi_{\ell-1},\pi_\ell\right]$ out of
      $\ell=1,\dots,L$ to which it belongs (where $\pi_0 := 0$).

      We require that 1 is in the set of tiles, $\pi$, but 0 isn't.

      This is how to use it.
      + make a tiles tuple using the function [[‚ê£xtiles_make()][~‚ê£xtiles_make()~]]
      + initialize the frequency vector with zeros
      + repeatedly call  [[‚ê£xtiles_count!()][~‚ê£xtiles_count!()~]], for every data point -- which must be in [0,1]
      + the frequency vector will contain the frequencies.

      Here's a pseudo-example:

      #+BEGIN_SRC julia :tangle no
        ùùÖ     = ‚ê£xtiles_make( [0.5, 0.8,0.9,0.99, 0.999, 1.0])  # 1 ‚àà ùùÖ  is required!!
        freqs = zeros(‚Ñù, length(ùùÖ))
        for j = 1:runs
            p‚±º = gimme_data_point(j)
            ‚ê£xtiles_count!(freqs, ùùÖ ; p‚±º , Œî=1/runs)
        end
      #+END_SRC


      For $\ell \ge 2$, ~freq[‚Ñì]~ is the frequency of the data points in the interval
      #+BEGIN_CENTER
                        \[
                        \left] \pi_{\ell-1} , \pi_{\ell} \right];
                        \]
      #+END_CENTER
      in the case $\ell=1$, ~freq[1]~ is the frequency of the data points in the interval
      #+BEGIN_CENTER
                        \[
                        \left[ 0 , \pi_{1} \right]
                        \]
      #+END_CENTER

      We require that 1 is in the set of tiles (but 0 isn't).

*** Create tiles tuple

      /We require that 1 is in the set of tiles!/

      #+NAME: ‚ê£xtiles_make()
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        function ‚ê£xtiles_make(_ùùÖ) ::Tuple
            ùùÖ = collect(_ùùÖ)
            sort!(ùùÖ)

            @assert allunique( ùùÖ )
            @assert 0.0 < ùùÖ[1] ‚â§ ùùÖ[end] == 1.0

            L = length(ùùÖ) # just saying...
            return (ùùÖ...,)
        end
      #+END_SRC

*** Store a data point

      #+NAME: ‚ê£xtiles_count!()
      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
        function ‚ê£xtiles_count!(freqs ::AbstractArray{‚Ñù},
                                ùùÖ     ::NTuple{L,‚Ñù}
                                ;
                                p     ::‚Ñù,
                                Œî     ::‚Ñù                 )::NamedTuple    where{L}
            @assert 0-1e-50 ‚â§ p
            @assert           p ‚â§ 1+1e-30
            @assert L == length(freqs)

            ‚Ñì = 1
            while ‚Ñì ‚â§ L   &&   ùùÖ[‚Ñì] < p
                ‚Ñì += 1
            end
            ‚Ñì = min(‚Ñì,L)                  # in case of rounding errors near 1.0

            freqs[ ‚Ñì ] += Œî

            return ( ‚Ñì=‚Ñì,  lo=get(ùùÖ,‚Ñì-1,0.0), hi=ùùÖ[‚Ñì] )
        end
      #+END_SRC

*** Let's test it!
**** Main testing function

      #+BEGIN_SRC julia :tangle test/runtests.jl
        function test__xtiles()

            function some_tests__interior(_ùùÖ)
                L     = length(_ùùÖ)
                m     = 16
                N     = m‚ãÖL
                ùùÖ     = DOT_StatsHelp.‚ê£xtiles_make(_ùùÖ)
                freqs = zeros(‚Ñù,L)

                for ‚Ñì = 1 : L
                    lo = get(ùùÖ,‚Ñì-1,   0.0)
                    hi =     ùùÖ[‚Ñì  ]
                    @test lo < hi || (lo==hi && ‚Ñì==L)
                    for j = 1:m
                        p =  lo + (hi-lo)‚ãÖrand()
                        iv = DOT_StatsHelp.‚ê£xtiles_count!(freqs,ùùÖ ; p, Œî=1/N)
                        @test iv.lo < p ‚â§ iv.hi
                    end
                end

                @test sum(freqs) ‚âà 1
                for ‚Ñì = 1:L
                    @test freqs[‚Ñì] ‚âà m/N
                end
            end

            function some_tests__boundary(_ùùÖ)
                L     = length(_ùùÖ)
                m     = 16
                N     = m‚ãÖL
                ùùÖ     = DOT_StatsHelp.‚ê£xtiles_make(_ùùÖ)
                freqs = zeros(‚Ñù,L)

                for j = 1:m
                    for ‚Ñì = 1:L
                        lo = get(ùùÖ,‚Ñì-1,   0.0)
                        hi =     ùùÖ[‚Ñì  ]
                        @test lo < hi || (lo==hi && ‚Ñì==L)
                        DOT_StatsHelp.‚ê£xtiles_count!(freqs,ùùÖ ; p=hi, Œî=1/N)
                    end
                end

                @test sum(freqs) ‚âà 1
                for ‚Ñì = 1:L
                    @test freqs[‚Ñì] ‚âà m/N
                end
            end

            for L = 1:10
                ùùÖ = [ rand(L-1)
                      1.0       ]
                some_tests__interior(ùùÖ)
                some_tests__boundary(ùùÖ)
            end
        end #^ test__Xtiles()
      #+END_SRC

**** Call the testing function
      #+BEGIN_SRC julia :tangle test/runtests.jl
        @testset verbose=true "DOT_StatsHelp.jl testing: Test Xtiles helper" begin
            test__xtiles()
        end
      #+END_SRC

** In-Tst The max-approx process type: ~MaxProc{L}~

     The following basic type is made available to the user:

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       export MaxProc
     #+END_SRC

     An object of this type collects information about the stochastic convergence of the maximum of random numbers
     to a known(!) limit.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       mutable struct MaxProc{L}
           # consts
           const ùùÖ         ::NTuple{L,‚Ñù}   # tiles numbers, sorted increasingly (last one must be 1.0)
           const freqs     ::Array{‚Ñù,2}    #
           const steps     ::Int
           const runs      ::Int

           # mutables
           true_max  ::‚Ñù
           curr_max  ::‚Ñù
           ùê´         ::Int    # index of current run (i.e., 0 ‚™Æ before first run)
           ùê¨         ::Int    # index of current step (i.e., 0 ‚™Æ before first step)
       end
      #+END_SRC

      ~freqs[s,:]~ is the vector of frequencies of the tiles in ~ùùÖ~, empirically over all data points given
      so far.

** TODO Usage
** In-Tst User-facing constructor for ~MaxApprox~
     <<max-constructor>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function MaxProc(_ùùÖ
                        ;
                        steps :: Int,
                        runs  :: Int )  ::MaxProc
     #+END_SRC

     About the arguments

     + ~_ùùÖ~ must be a list (array, tuple, generator, ...) of tiles, as type-~‚Ñù~ numbers in $\left]0,1\right]$.  *It
       must include 1=100%,* but it must not include 0.

*** Implementation

      #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
            ùùÖ     = ‚ê£xtiles_make(_ùùÖ)
            L     = length(ùùÖ)
            freqs = Array{‚Ñù,2}(undef,steps,L)
            s     = MaxProc{L}(ùùÖ, freqs, steps, runs, Inf, Inf, 0,0)
            ‚ê£integrity_check(s)
            return s
        end
      #+END_SRC

** In-Tst Helper functions and integrity check
     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       numo_stepsruns( s ::MaxProc{L} ) where{L}    = ( numo_steps(s) , numo_runs(s) )
       numo_steps(     s ::MaxProc{L} ) where{L}    = s.steps
       numo_runs(      s ::MaxProc{L} ) where{L}    = s.runs
      #+END_SRC

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function ‚ê£integrity_check(s ::MaxProc{L}) ::Nothing where{L}
           @assert L           == length(s.ùùÖ)  "Crazy bug!!"
           @assert 0 < s.ùùÖ[1] < s.ùùÖ[end] == 1.0
           @assert (L,s.steps) == size(s.freqs)
           @assert s.steps     == numo_steps(s)
           @assert s.runs      == numo_runs(s)
           @assert s.steps ‚â• 1
           @assert s.runs  ‚â• 1

           @assert 0 ‚â§ s.ùê¨ ‚â§ s.steps
           @assert 0 ‚â§ s.ùê´ ‚â§ s.runs
           @assert s.ùê´ ‚â• 1 || s.ùê¨ == 0

           @assert s.curr_max ‚â§ s.true_max

           nothing;
       end
     #+END_SRC

** In-Tst Starting a new run: ~start_run!()~
     <<max-start>>

     When a new run starts, the true mean has to be recorded, the indices ùê´ and ùê¨ for run and step, resp., have to
     be set up, and the empirical data has to be initialized.

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function start_run!(s        :: MaxProc{L}
                           ;
                           true_max :: ‚Ñù            ) ::Nothing  where{L}
           ‚ê£integrity_check(s)

           if    s.ùê´ > 0           @assert s.ùê¨ == numo_steps(s)
           else                    @assert s.ùê¨ == 0               end

           s.ùê´ += 1              ; @assert s.ùê´ ‚â§ numo_runs(s)
           s.ùê¨  = 0

           s.true_max = true_max
           s.curr_max = -Inf

           nothing;
       end
     #+END_SRC

** In-Tst Adding data of a step: ~record_step!()~
     <<max-record>>

     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function record_step!(s ::MaxProc{L}
                             ;
                             ùê∏ ::‚Ñù            ) ::Union{‚Ñù,Nothing}     where{L}
           ‚ê£integrity_check(s)

           @assert 0 ‚â§ ùê∏ ‚â§ s.true_max

           (;runs,true_max,ùùÖ,freqs) = s

           new_max ::Bool = false
           if ùê∏ > s.curr_max
               s.curr_max = ùê∏
               new_max    = true
           end

           s.ùê¨        += 1            ; @assert s.ùê¨ ‚â§ numo_steps(s)
           freqs‚Çõ    =  @view freqs[:,s.ùê¨]
           (;‚Ñì,lo,hi) =  ‚ê£xtiles_count!(freqs‚Çõ, ùùÖ
                                       ; p = s.curr_max / true_max,  Œî=1/runs)

           if new_max
               @info "New max: $ùê∏; ‚Ñì=$‚Ñì, lo=$lo, hi=$hi"
               return lo
           end
           nothing;
       end #^ record_step!()
     #+END_SRC

** In-Tst Finalizing a run: ~finalize_run!()~                  <<max-finalize>>

    This version of ~finalize...()~ returns the maximum.


     #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
       function finalize_run!(s ::MaxProc{L}) ::‚Ñù         where{L}
           ‚ê£integrity_check(s)

           @assert s.ùê¨ == numo_steps(s)
           @assert 0 ‚â§ s.curr_max

           return s.curr_max
       end #^ finalize_run!()
     #+END_SRC

** TODO Tests for the max process


* End of module

    #+BEGIN_SRC julia :tangle src/DOT_StatsHelp.jl
      end #^ module SPSA_Shift
    #+END_SRC

    That's it!



* EOOF
# Local Variables:
# fill-column: 115
# End:
